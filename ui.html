<!DOCTYPE html>
<html>
<head>
<style>
* {
	box-sizing: border-box;
}
html, body {
	width: 100%;
	height: 100%;
	padding: 0;
	margin: 0;
	border: 0;
	overflow: hidden;
}
body {
	display: flex;
	position: relative;
	background: black;
}
.ui_canvas {
	position: absolute;
}
</style>
</head>
<body>
<canvas class=ui_canvas id=canvas></canvas>
<script>

(function () {
"use strict"
let G = window

/*

GOALS

- drag & drop UI designer with anchors
- reusable UI modules with controlled variations
- IMGUI with layers and layouting
- remote screen sharing with input routing

IMGUI

- drawing
	- z-index
	* text
	* bg-color
	* border
	* box-shadow
	- images (incl. svg?)
- layouting
	* min width & height
	* flexbox fr stretch
	* flexbox min-w/h grow
	* flexbox align
	* flexbox gap
	* stack
	* padding
	* margin
	* text min-w/h
	- word-wrapping
	- grid fr stretch
	- grid min-w/h grow
	- grid align
	- grid gap
- mouse
	* hit-test rect
	* hit state
	* hit parents
	* capturing
	* capture state
	- drag & drop
- keyboard
	- focused widget
	- event bubbling
- text selection
	- drag-select with mouse
- text(area) input
	- put it behind the canvas with correct width & height
		- route keyboard events to it
		- redraw it on canvas with offset and selection
- transition animations
- popup layouting

CHALLENGES

- input on a canvas
- textarea on a canvas
- webgl2 canvas on a 2d canvas
- word wrapping (our layout algo supports word-wrapping for horizontal text)
- rich text on a canvas (inline box model)

PROS vs WEB
- stateless i.e. reactive / IMGUI (but with layouting and z-index and no frame lag)
- simpler and far more productive layouting and styling models
- global z-index, allowing for:
	- relatively-positioned but painted-last popups
	- painted-last focus ring
- transition animations for in-layout objects, allowing for:
	- animated element moving, drag/drop and selection under/overlays
- streamable and replayable rendering, for sreen-sharing and remote interaction
- super-fast and memory-efficient with very low gc pressure between frames.
- complex widgets built with a combination of box-stacking and custom-drawing.

CONS vs WEB
- must reimplement:
	- text selection & clipboard ops
	- scrollbox
	- word-wrapping
	- inline layouting with:
		- u, b, i, strike, sub, sup, h1..6, p, br, hr, float
- no fancy typography:
	- no smart word-wrapping (Thai, auto-hyphenation)
	- no BiDi
	- no smart underline (interrupted by letter descenders)
-

*/

// ---------------------------------------------------------------------------

G.isobject = e => e != null && typeof e == 'object' // includes arrays, HTMLElements, etc.
G.isarray = Array.isArray
G.isobj = t => isobject(t) && (t.constructor == Object || t.constructor === undefined)
G.isstr = s => typeof s == 'string'
G.isnum = n => typeof n == 'number'
G.isbool = b => typeof b == 'boolean'
G.isfunc = f => typeof f == 'function'

G.assert = function(ret, err, ...args) {
	if (ret == null || ret === false) {
		throw ((err && err.subst(...args) || 'assertion failed'))
	}
	return ret
}

G.pr = console.log
G.trace = console.trace

G.floor = Math.floor
G.ceil  = Math.ceil
G.round = Math.round
G.max   = Math.max
G.min   = Math.min

// NOTE: returns x1 if x1 < x0, which enables the idiom
// `a[clamp(i, 0, b.length-1)]` to return undefined when b is empty.
G.clamp = function(x, x0, x1) {
	return min(max(x, x0 ?? -1/0), x1 ?? 1/0)
}

Number.prototype.dec = Number.prototype.toFixed

G.num = function(s) {
	let x = parseFloat(s)
	return x != x ? undefined : x
}

// usage:
//	 '{1} of {0}'.subst(total, current)
//	 '{1} of {0}'.subst([total, current])
//	 '{1} of {0:foo:foos}'.subst([total, current])
//	 '{current} of {total}'.subst({'current': current, 'total': total})
String.prototype.subst = function(...args) {
	if (!args.length)
		return this.valueOf()
	if (isarray(args[0]))
		args = args[0]
	if (isobject(args[0]))
		args = args[0]
	return this.replace(/{(\w+)\:(\w+)\:(\w+)}/g, function(match, s, singular, plural) {
		let v = num(args[s])
		return v != null ? v + ' ' + (v > 1 ? plural : singular) : s
	}).replace(/{([\w\:]+)}/g, (match, s) => args[s])
}

String.prototype.starts = function(s, i) { return this.startsWith(s, i) }
String.prototype.ends   = function(s, i) { return this.endsWith(s, i) }
String.prototype.upper  = function() { return this.toUpperCase() }
String.prototype.lower  = function() { return this.toLowerCase() }

G.obj = () => Object.create(null)
G.set = (iter) => new Set(iter)
G.map = (iter) => new Map(iter)
G.array = (...args) => new Array(...args)

G.noop = function() {}

G.json = JSON.stringify

G.clock = function() { return performance.now() / 1000 }

EventTarget.prototype.on = function(event, f, on) {
	if (on == null)
		on = true
	if (on)
		this.addEventListener(event, f)
	else
		this.removeEventListener(event, f)
}

// ---------------------------------------------------------------------------

G.ui = {}

G.DEBUG = false

function map_freelist() {
	let fl = []
	return function(m) {
		if (m) {
			m.clear()
			fl.push(m)
		} else {
			m = fl.pop()
			return m || map()
		}
	}
}

// ---------------------------------------------------------------------------

let dpr, screen_w, screen_h

function resize_canvas() {
	dpr = devicePixelRatio
	let window_w = window.innerWidth
	let window_h = window.innerHeight
	screen_w = floor(window_w * dpr)
	screen_h = floor(window_h * dpr)
	canvas.style.width  = screen_w / dpr + 'px'
	canvas.style.height = screen_h / dpr + 'px'
	canvas.width  = screen_w
	canvas.height = screen_h
	redraw()
}
let cx = canvas.getContext('2d')
let raf_id
let max_frame_duration = 0
let last_frame_duration = 0
function raf_redraw() {
	raf_id = null
	let t0 = clock()
	cx.save()
	cx.clearRect(0, 0, canvas.width, canvas.height)
	redraw_all()
	cx.restore()
	last_frame_duration = clock() - t0
	if (max_frame_duration)
		max_frame_duration = max(last_frame_duration, max_frame_duration)
	else
		max_frame_duration = 0.000001
}
function redraw() {
	if (raf_id) return
	raf_id = requestAnimationFrame(raf_redraw)
}
resize_canvas()
redraw()
window.on('resize', resize_canvas)

// ---------------------------------------------------------------------------

let mx, my, mx0, my0, down, captured_id

canvas.on('pointerdown', function(ev) {
	mx = ev.clientX * dpr
	my = ev.clientY * dpr
	if (ev.which == 1) {
		down = true
		this.setPointerCapture(ev.pointerId)
		hit_test_all()
		redraw()
	}
})

canvas.on('pointerup', function(ev) {
	mx = ev.clientX * dpr
	my = ev.clientY * dpr
	if (ev.which == 1) {
		down = false
		captured_id = null
		this.releasePointerCapture(ev.pointerId)
		hit_test_all()
		redraw()
	}
})

canvas.on('pointermove', function(ev) {
	mx = ev.clientX * dpr
	my = ev.clientY * dpr
	hit_test_all()
	redraw()
})

canvas.on('pointerleave', function(ev) {
	mx = null
	my = null
	hit_test_all()
	redraw()
})

let capture_state = map()

function capture(id) {
	if (!id)
		return
	if (captured_id)
		return
	if (!down)
		return
	if (!hit_set.has(id))
		return
	captured_id = id
	capture_state.clear()
	mx0 = mx
	my0 = my
	return capture_state
}

function captured(id) {
	if (!id)
		return
	if (captured_id != id)
		return
	return capture_state
}

// ---------------------------------------------------------------------------

function layer_make() {
	let e = [] // [i1,n1,...]
	layer_clear(e)
	return e
}

function layer_clear(e) {
	e.length = 0
}

let layer_base  = layer_make()
let layer_popup = layer_make()

let a = []

a.layers = [layer_base, layer_popup]

let layer_stack = []

function push_layer(layer) {
	layer_stack.push(layer)
	layer.push(a.length)
}

ui.push_layer_base  = function() { push_layer(layer_base ) }
ui.push_layer_popup = function() { push_layer(layer_popup) }

ui.pop_layer = function() {
	let layer = assert(layer_stack.pop(), 'no layer')
	layer.push(a.length)
}

// ---------------------------------------------------------------------------

let id_state_map_freelist = map_freelist()
let id_state_maps = map() // {id->map}
let id_current_set = set() // {id}
let id_remove_set  = set() // {id}

function id_touch(id) {
	id_current_set.add(id)
	id_remove_set.delete(id)
}

function id_state(id) {
	if (!id)
		return
	id_touch(id)
	let m = id_state_maps.get(id)
	if (!m) {
		m = id_state_map_freelist()
		id_state_maps.set(id, m)
	}
	return m
}

function id_state_gc() {
	for (let id of id_remove_set) {
		let m = id_state_maps.get(id)
		id_state_maps.delete(id)
		id_state_map_freelist(m)
	}
	id_remove_set.clear()
	let empty = id_remove_set
	id_remove_set = id_current_set
	id_current_set = empty
}

// ---------------------------------------------------------------------------

let cmd_names = []
let cmd_name_map = map()

let measure   = []
let position  = []
let draw      = []
let hit       = []

function cmd(code, name) {
	assert(!cmd_names[code], 'duplicate command code {0} for {1}', code, name)
	cmd_names[code] = name
	cmd_name_map.set(name, code)
	return code
}

ui.widget = function(e) {
	cmd(e.code, e.name)
	measure  [code] = e.measure
	position [code] = e.position
	draw     [code] = e.draw
	hit      [code] = e.hit
}

let color, font, font_size

function reset_text() {
	color = null
	font = null
	font_size = null
}

function ui_cmd(cmd, ...args) {
	let i0 = a.length+2   // index of this cmd's arg#1
	let i1 = i0+args.length+3 // index of next cmd's arg#1
	a.push(i1, cmd, ...args, i0)
	return i0
}

let ct_stack = [] // [ct_i1,...]
let ct_x = 0
let ct_y = 0

const PX1        =  4
const PX2        =  6
const MX1        =  8
const MX2        = 10

const FR         = 12 // children of v,h: fraction from main-axis size.
const ALIGN      = 13 // all children: align v,h.
const NEXT_EXT_I = 15 // all containers: next command after this one's `end`.
const S          = 16 // first index after the cell struct.

const FLEX_GAP      = S+0
const FLEX_TOTAL_FR = S+1

const ALIGN_STRETCH = 0
const ALIGN_START   = 1
const ALIGN_END     = 2
const ALIGN_CENTER  = 3

function parse_align(s) {
	if (s == 's') return ALIGN_STRETCH
	if (s == 'c') return ALIGN_CENTER
	if (s == 'l') return ALIGN_START
	if (s == 'r') return ALIGN_END
	if (s == '[') return ALIGN_START
	if (s == ']') return ALIGN_END
	if (s == 'stretch') return ALIGN_STRETCH
	if (s == 'center' ) return ALIGN_CENTER
	if (s == 'left'   ) return ALIGN_START
	if (s == 'right'  ) return ALIGN_END
	assert(false, 'invalid align {0}', s)
}

function parse_valign(s) {
	if (s == 's') return ALIGN_STRETCH
	if (s == 'c') return ALIGN_CENTER
	if (s == 't') return ALIGN_START
	if (s == 'b') return ALIGN_END
	if (s == '[') return ALIGN_START
	if (s == ']') return ALIGN_END
	if (s == 'stretch') return ALIGN_STRETCH
	if (s == 'center' ) return ALIGN_CENTER
	if (s == 'top'    ) return ALIGN_START
	if (s == 'bottom' ) return ALIGN_END
	assert(false, 'invalid valign {0}', s)
}

// paddings and margins, applied to the next box cmd and then they are reset.
let px1, px2, py1, py2
let mx1, mx2, my1, my2

ui.padding = function(_px1, _px2, _py1, _py2) {
	px1 = _px1
	px2 = _px2
	py1 = _py1
	py2 = _py2
}
ui.p = ui.padding

ui.margin = function(_mx1, _mx2, _my1, _my2) {
	mx1 = _mx1
	mx2 = _mx2
	my1 = _my1
	my2 = _my2
}
ui.m = ui.margin

function reset_paddings() {
	px1 = 0
	py1 = 0
	px2 = 0
	py2 = 0
	mx1 = 0
	my1 = 0
	mx2 = 0
	my2 = 0
}
reset_paddings()

function ui_hv(cmd, fr, gap, align, valign, min_w, min_h) {
	let i = ui_cmd(cmd,

		// cell struct
		0, // x
		0, // y
		min_w ?? 0,
		min_h ?? 0,
		px1, py1, px2, py2,
		mx1, my1, mx2, my2,
		fr ?? 1,
		parse_align  (align  ?? 's'),
		parse_valign (valign ?? 's'),

		0, // next_ext_i

		gap ?? 0,
		0, // total_fr
	)
	ct_stack.push(i)
	reset_paddings()
}

const CMD_H = cmd(1, 'h')
const CMD_V = cmd(2, 'v')

ui.h = function(...args) { ui_hv(CMD_H, ...args) }
ui.v = function(...args) { ui_hv(CMD_V, ...args) }

let CMD_STACK = cmd(3, 'stack')
ui.stack = function(fr, align, valign, min_w, min_h) {
	let i = ui_cmd(CMD_STACK,

		// cell struct
		0, // x
		0, // y
		min_w ?? 0, // min_w
		min_h ?? 0, // min_h
		px1, py1, px2, py2,
		mx1, my1, mx2, my2,
		fr ?? 1,
		parse_align  (align  ?? 's'),
		parse_valign (valign ?? 's'),

		0, // next_ext_i
	)
	ct_stack.push(i)
	reset_paddings()
}

const SB_OVERFLOW =  S+0 // overflow x,y
const SB_CW       =  S+2 // content w,h
const SB_ID       =  S+4
const SB_SX       =  S+5 // scroll x,y

const CMD_SCROLLBOX = cmd(4, 'scrollbox')
ui.scrollbox = function(id, fr, overflow_x, overflow_y, align, valign, min_w, min_h, sx, sy) {

	let ss = id_state(id)
	sx = sx ?? (ss ? ss.get('scroll_x') : 0)
	sy = sy ?? (ss ? ss.get('scroll_y') : 0)

	let i = ui_cmd(CMD_SCROLLBOX,

		// cell struct
		0, // x
		0, // y
		0, // content w swapped with min_w on `end`
		0, // content h swapped with min_h on `end`
		px1, py1, px2, py2,
		mx1, my1, mx2, my2,
		fr ?? 1,
		parse_align  (align  ?? 's'),
		parse_valign (valign ?? 's'),

		0, // next_ext_i

		overflow_x ?? 'auto',
		overflow_y ?? 'auto',
		min_w ?? 0, // swapped with content w on `end`
		min_h ?? 0, // swapped with content h on `end`
		id,
		sx ?? 0, // scroll x
		sy ?? 0, // scroll y
	)
	ct_stack.push(i)
	reset_paddings()

	if (ss) {
		ss.set('scroll_x', sx)
		ss.set('scroll_y', sy)
	}
}

const POPUP_SIDE_CENTER       = 0 // only POPUP_SIDE_INNER_CENTER is valid!
const POPUP_SIDE_LEFT         = 1
const POPUP_SIDE_RIGHT        = 2
const POPUP_SIDE_TOP          = 3
const POPUP_SIDE_BOTTOM       = 4
const POPUP_INNER             = 8 // own bit!
const POPUP_SIDE_INNER_CENTER = POPUP_INNER + POPUP_SIDE_CENTER
const POPUP_SIDE_INNER_LEFT   = POPUP_INNER + POPUP_SIDE_LEFT
const POPUP_SIDE_INNER_RIGHT  = POPUP_INNER + POPUP_SIDE_RIGHT
const POPUP_SIDE_INNER_TOP    = POPUP_INNER + POPUP_SIDE_TOP
const POPUP_SIDE_INNER_BOTTOM = POPUP_INNER + POPUP_SIDE_BOTTOM

const POPUP_ALIGN_CENTER = 0
const POPUP_ALIGN_START  = 1
const POPUP_ALIGN_END    = 2

function popup_parse_side(s) {
	if (s == '['           ) return POPUP_SIDE_LEFT
	if (s == ']'           ) return POPUP_SIDE_RIGHT
	if (s == 'l'           ) return POPUP_SIDE_LEFT
	if (s == 'r'           ) return POPUP_SIDE_RIGHT
	if (s == 't'           ) return POPUP_SIDE_TOP
	if (s == 'b'           ) return POPUP_SIDE_BOTTOM
	if (s == 'ic'          ) return POPUP_SIDE_INNER_CENTER
	if (s == 'il'          ) return POPUP_SIDE_INNER_LEFT
	if (s == 'ir'          ) return POPUP_SIDE_INNER_RIGHT
	if (s == 'it'          ) return POPUP_SIDE_INNER_TOP
	if (s == 'ib'          ) return POPUP_SIDE_INNER_BOTTOM
	if (s == 'left'        ) return POPUP_SIDE_LEFT
	if (s == 'right'       ) return POPUP_SIDE_RIGHT
	if (s == 'top'         ) return POPUP_SIDE_TOP
	if (s == 'bottom'      ) return POPUP_SIDE_BOTTOM
	if (s == 'inner-center') return POPUP_SIDE_INNER_CENTER
	if (s == 'inner-left'  ) return POPUP_SIDE_INNER_LEFT
	if (s == 'inner-right' ) return POPUP_SIDE_INNER_RIGHT
	if (s == 'inner-top'   ) return POPUP_SIDE_INNER_TOP
	if (s == 'inner-bottom') return POPUP_SIDE_INNER_BOTTOM
	assert(false, 'invalid popup side {0}', s)
}

function popup_parse_align(s) {
	if (s == 'c'     ) return POPUP_ALIGN_CENTER
	if (s == '['     ) return POPUP_ALIGN_START
	if (s == ']'     ) return POPUP_ALIGN_END
	if (s == 'center') return POPUP_ALIGN_CENTER
	if (s == 'start' ) return POPUP_ALIGN_START
	if (s == 'end'   ) return POPUP_ALIGN_END
	assert(false, 'invalid align {0}', s)
}

const POPUP_SIDE  = S+0
const POPUP_ALIGN = S+1
const POPUP_FIXED = S+2

const CMD_POPUP = cmd(5, 'popup')
ui.popup = function(id, side, align, fixed, min_w, min_h) {
	let i = ui_cmd(CMD_POPUP,

		// cell struct but out-of-layout (no fr or align)
		0, // x
		0, // y
		min_w ?? 0, // min_w
		min_h ?? 0, // min_h
		px1, py1, px2, py2,
		mx1, my1, mx2, my2,
		0, 0, 0, 0, // TODO: not used but written to, remove it!

		popup_parse_side(side ?? 't'),
		popup_parse_align(align ?? 'c'),
		fixed,
	)
	ct_stack.push(i)
	reset_paddings()
}

const CMD_END = cmd(19, 'end')
ui.end = function(cmd_name) {
	let i = assert(ct_stack.pop(), 'end command outside container')
	if (cmd_name) {
		let cmd1 = assert(cmd_name_map.get(cmd_name))
		let cmd0 = a[i-1]
		assert(cmd0 == cmd1)
	}
	let end_i = ui_cmd(CMD_END, i)
	a[i+NEXT_EXT_I] = a[end_i-2] // next_i
}

const BORDER_SIDE_T = 1
const BORDER_SIDE_R = 2
const BORDER_SIDE_B = 4
const BORDER_SIDE_L = 8
const BORDER_SIDE_ALL = 15

function parse_border_sides(s) {
	if (!s) // 0, null, undefined
		return 0
	if (s == true) // true, 1
		return BORDER_SIDE_ALL
	return (
		(s.includes('l') ? BORDER_SIDE_L : 0) +
		(s.includes('r') ? BORDER_SIDE_R : 0) +
		(s.includes('t') ? BORDER_SIDE_T : 0) +
		(s.includes('b') ? BORDER_SIDE_B : 0)
	)
}

const CMD_RECT = cmd(20, 'rect')
ui.rect = function(bg_color, sides, border_color, border_radius) {
	ui_cmd(CMD_RECT, bg_color, parse_border_sides(sides), border_color, border_radius)
}

const CMD_SHADOW = cmd(21, 'shadow')
ui.shadow = function(color, blur, x, y) {
	ui_cmd(CMD_SHADOW, color, blur, x, y)
}

const TEXT_ASC = S-1
const TEXT_ID  = S+0
const TEXT_S   = S+1

const CMD_TEXT = cmd(22, 'text')
ui.text = function(id, s, align, valign, fr) {
	ui_cmd(CMD_TEXT,

		// cell struct
		0, // x
		0, // y
		0, // min_w, measured
		0, // min_h, measured
		px1, py1, px2, py2,
		mx1, my1, mx2, my2,
		fr ?? 0,
		parse_align  (align  ?? '['),
		parse_valign (valign ?? 'c'),

		0, // ascent
		id,
		s,
	)
	reset_paddings()
}

const CMD_COLOR = cmd(23, 'color')
ui.color = function(s) {
	if (color == s) return
	ui_cmd(CMD_COLOR, s)
	color = s
}

const CMD_FONT = cmd(24, 'font')
ui.font = function(s) {
	if (font == s) return
	ui_cmd(CMD_FONT, s)
	font = s
}

const CMD_FONT_SIZE = cmd(25, 'font_size')
ui.font_size = function(s) {
	if (font_size == s) return
	ui_cmd(CMD_FONT_SIZE, s)
	font_size = s
}

function set_font(a, i) {
	font = a[i]
	cx.font = font_size + 'px ' + font
}

function set_font_size(a, i) {
	font_size = a[i]
	cx.font = font_size + 'px ' + font
}

function get_next_ext_i(a, i) {
	let cmd = a[i-1]
	if (cmd < CMD_END)
		return a[i+NEXT_EXT_I]
	return a[i-2] // next_i
}

// ---------------------------------------------------------------------------

function is_main_axis(cmd, axis) {
	return (
		(cmd == CMD_V ? 1 : 2) == axis ||
		(cmd == CMD_H ? 0 : 2) == axis
	)
}

function paddings(a, i, axis) {
	return a[i+MX1+axis] + a[i+MX2+axis] + a[i+PX1+axis] + a[i+PX2+axis]
}

function add_ct_min_wh(a, axis, w, fr) {
	let i = assert(ct_stack.at(-1), 'object outside container')
	let cmd = a[i-1]
	let main_axis = is_main_axis(cmd, axis)
	let min_w = a[i+2+axis]
	if (main_axis) {
		a[i+FLEX_TOTAL_FR] += fr
		let gap = a[i+FLEX_GAP]
		a[i+2+axis] = min_w + w + gap
	} else {
		a[i+2+axis] = max(min_w, w)
	}
}

measure[CMD_FONT] = set_font
measure[CMD_FONT_SIZE] = set_font_size

measure[CMD_TEXT] = function(a, i, axis) {
	let fr = a[i+FR]
	if (!axis) {
		let s = a[i+TEXT_S]
		let m = cx.measureText(s)
		let asc = m.fontBoundingBoxAscent
		let dsc = m.fontBoundingBoxDescent
		a[i+2] = ceil(m.width) + paddings(a, i, 0)
		a[i+3] = ceil(asc+dsc) + paddings(a, i, 1)
		a[i+TEXT_ASC] = round(asc)
	}
	let w = a[i+2+axis]
	add_ct_min_wh(a, axis, w, fr)
}

function ct_stack_push(a, i) {
	ct_stack.push(i)
}

measure[CMD_H        ] = ct_stack_push
measure[CMD_V        ] = ct_stack_push
measure[CMD_STACK    ] = ct_stack_push
measure[CMD_POPUP    ] = ct_stack_push
measure[CMD_SCROLLBOX] = ct_stack_push

measure[CMD_END] = function(a, _, axis) {
	let i = assert(ct_stack.pop(), 'end command outside a container')
	if (!ct_stack.length)
		return
	let cmd = a[i-1]
	if (cmd == CMD_SCROLLBOX) {
		let co_min_w = a[i+2+axis] // content min_w
		let sb_min_w = a[i+SB_CW+axis] // scrollbox min_w
		a[i+SB_CW+axis] = co_min_w
		a[i+2+axis] = sb_min_w + paddings(a, i, axis)
		let fr = a[i+FR]
		add_ct_min_wh(a, axis, sb_min_w, fr)
	} else if (cmd == CMD_POPUP) {
		// popups don't affect their target's layout.
	} else {
		let main_axis = is_main_axis(cmd, axis)
		if (main_axis)
			a[i+2+axis] = max(0, a[i+2+axis] - a[i+FLEX_GAP]) // remove last element's gap
		a[i+2+axis] += paddings(a, i, axis)
		let min_w = a[i+2+axis]
		let fr    = a[i+FR]
		add_ct_min_wh(a, axis, min_w, fr)
	}
}

function measure_all(axis) {
	reset_text()
	let i = 2
	let n = a.length
	while (i < n) {
		let cmd = a[i-1]
		let measure_f = measure[cmd]
		if (measure_f)
			measure_f(a, i, axis)
		i = a[i-2] // next_i
	}
	assert(!ct_stack.length)
}

// ---------------------------------------------------------------------------

function position_children_cross_axis(a, i, axis, ct_w) {

	while (a[i-1] != CMD_END) {

		let cmd = a[i-1]
		let position_f = position[cmd]

		if (position_f) {

			let min_w = a[i+2+axis]
			let align = a[i+ALIGN+axis]

			// stretch or align the item on the cross-axis.
			let x = 0
			let w = align == ALIGN_STRETCH ? ct_w : min_w
			if (align == ALIGN_END)
				x = ct_w - w
			else if (align == ALIGN_CENTER)
				x = round((ct_w - w) / 2)

			// position item's children recursively.
			position_f(a, i, axis, x, w)

		}

		i = get_next_ext_i(a, i)
	}
}

function position_flex(a, i, axis, ct_x, ct_w) {

	ct_stack.push(i)

	a[i+0+axis] = ct_x
	a[i+2+axis] = ct_w

	let main_axis = is_main_axis(a[i-1], axis)
	let next_i = a[i-2]
	let i0 = i

	let total_w = ct_w
		- a[i0+MX1+axis] - a[i0+MX2+axis]
		- a[i0+PX1+axis] - a[i0+PX2+axis]

	if (main_axis) {

		let gap      = a[i0+FLEX_GAP]
		let total_fr = a[i0+FLEX_TOTAL_FR]

		// compute total gap.
		let gap_w = 0
		if (gap) {
			let n = 0
			let i = next_i
			while (a[i-1] != CMD_END) {
				if (position[a[i-1]])
					n++
				i = get_next_ext_i(a, i)
			}
			gap_w = n * gap
		}
		total_w -= gap_w

		// compute total overflow width and total free width.
		let total_overflow_w = 0
		let total_free_w     = 0
		let i = next_i
		while (a[i-1] != CMD_END) {

			let cmd = a[i-1]
			if (position[cmd]) {

				let min_w = a[i+2+axis]
				let fr    = a[i+FR]

				let flex_w = total_w * max(0, fr) / total_fr
				let overflow_w = max(0, min_w - flex_w)
				let free_w = max(0, flex_w - min_w)
				total_overflow_w += overflow_w
				total_free_w     += free_w

			}

			i = get_next_ext_i(a, i)
		}

		// distribute the overflow to children which have free space to
		// take it. each child shrinks to take in the percent of the overflow
		// equal to the child's percent of free space.
		i = next_i
		let sx = 0
		while (a[i-1] != CMD_END) {

			let cmd = a[i-1]
			let position_f = position[cmd]

			if (position_f) {

				let min_w = a[i+2+axis]
				let fr    = a[i+FR]
				let align = a[i+ALIGN+axis]

				// compute item's stretched width.
				let flex_w = total_w * fr / total_fr
				let sw
				if (min_w > flex_w) { // overflow
					sw = min_w
				} else {
					let free_w = flex_w - min_w
					let free_p = free_w / total_free_w
					let shrink_w = total_overflow_w * free_p
					if (shrink_w != shrink_w) // total_free_w == 0
						shrink_w = 0
					sw = flex_w - shrink_w
				}

				// align the item inside the stretched segment defined by (sx, sw).
				let x = sx
				let w = align == ALIGN_STRETCH ? sw : min_w
				if (align == ALIGN_END)
					x = sx + sw - w
				else if (align == ALIGN_CENTER)
					x = round(sx + (sw - w) / 2)

				// position item's children recursively.
				position_f(a, i, axis, x, w)

				sx = sx + sw + gap

			}

			i = get_next_ext_i(a, i)
		}

	} else {

		position_children_cross_axis(a, next_i, axis, total_w)

	}

	ct_stack.pop()

}

position[CMD_H    ] = position_flex
position[CMD_V    ] = position_flex
position[CMD_STACK] = position_flex

position[CMD_SCROLLBOX] = function(a, i, axis, ct_x, ct_w) {

	ct_stack.push(i)

	let co_w = a[i+SB_CW+axis] // scrollbox content w
	let next_i = a[i-2]

	a[i+0+axis] = ct_x
	a[i+2+axis] = ct_w

	position_children_cross_axis(a, next_i, axis, max(co_w, ct_w))

	// update sx,sy once.
	if (axis) {

		let x  = a[i+0]
		let y  = a[i+1]
		let w  = a[i+2]
		let h  = a[i+3]
		let cw = a[i+SB_CW]
		let ch = a[i+SB_CW+1]
		let sx = a[i+SB_SX]
		let sy = a[i+SB_SX+1]

		sx = max(0, min(sx, cw - w))
		sy = max(0, min(sy, ch - h))

		let psx = sx / (cw - w)
		let psy = sy / (ch - h)
		let pw = w / cw
		let ph = h / ch
		let thickness = 10

		let id = a[i+SB_ID]
		if (id) {
			for (let axis = 0; axis < 2; axis++) {

				let [visible, tx, ty, tw, th] = scrollbar_rect(a, i, axis)
				if (!visible)
					continue

				let sbar_id = id+'.scrollbar'+axis
				let cs = captured(sbar_id)
				if (cs) {
					if (!axis) {
						let psx0 = cs.get('ps0')
						let dpsx = (mx - mx0) / (w - tw)
						sx = clamp(psx0 + dpsx, 0, 1) * (cw - w)
						id_state(id).set('scroll_x', sx)
						a[i+SB_SX] = sx
					} else {
						let psy0 = cs.get('ps0')
						let dpsy = (my - my0) / (h - th)
						sy = clamp(psy0 + dpsy, 0, 1) * (ch - h)
						id_state(id).set('scroll_y', sy)
						a[i+SB_SX+1] = sy
					}
					break
				} else {
					let hs = hovers(sbar_id)
					if (!hs)
						continue
					let cs = capture(sbar_id)
					if (!cs)
						continue
					cs.set('ps0', !axis ? psx : psy)
				}
			}
		}

	}

	ct_stack.pop()

}

{
let x, y
function position_popup(w, h, side, align, tx1, ty1, tx2, ty2) {

	let tw = tx2 - tx1
	let th = ty2 - ty1

	if (side == POPUP_SIDE_RIGHT) {
		;[x, y] = [tx2, ty1]
	} else if (side == POPUP_SIDE_LEFT) {
		;[x, y] = [tx1 - w, ty1]
	} else if (side == POPUP_SIDE_TOP) {
		;[x, y] = [tx1, ty1 - h]
	} else if (side == POPUP_SIDE_BOTTOM) {
		;[x, y] = [tx1, ty2]
	} else if (side == POPUP_SIDE_INNER_RIGHT) {
		;[x, y] = [tx2 - w, ty1]
	} else if (side == POPUP_SIDE_INNER_LEFT) {
		;[x, y] = [tx1, ty1]
	} else if (side == POPUP_SIDE_INNER_TOP) {
		;[x, y] = [tx1, ty1]
	} else if (side == POPUP_SIDE_INNER_BOTTOM) {
		;[x, y] = [tx1, ty2 - h]
	} else if (side == POPUP_SIDE_INNER_CENTER) {
		;[x, y] = [
			tx1 + (tw - w) / 2,
			ty1 + (th - h) / 2
		]
	} else {
		assert(false)
	}

	let sd = side & ~POPUP_INNER
	let sdx = sd == POPUP_SIDE_LEFT || sd == POPUP_SIDE_RIGHT
	let sdy = sd == POPUP_SIDE_TOP  || sd == POPUP_SIDE_BOTTOM
	if (align == POPUP_ALIGN_CENTER && sdy)
		x = x + (tw - w) / 2
	else if (align == POPUP_ALIGN_CENTER && sdx)
		y = y + (th - h) / 2
	else if (align == POPUP_ALIGN_END && sdy)
		x = x + tw - w
	else if (align == POPUP_ALIGN_END && sdx)
		y = y + th - h
}

position[CMD_POPUP] = function(a, i, axis, ct_x, ct_w) {

	ct_stack.push(i)

	let min_w = a[i+2+axis]
	let next_i = a[i-2]
	position_children_cross_axis(a, next_i, axis, min_w)

	if (axis) {

		let ct_i = assert(ct_stack.at(-2), 'popup outside container')
		let tx1 = a[ct_i+0]
		let ty1 = a[ct_i+1]
		let tx2 = a[ct_i+2] + tx1
		let ty2 = a[ct_i+3] + ty1

		let w     = a[i+2]
		let h     = a[i+3]
		let side  = a[i+POPUP_SIDE]
		let align = a[i+POPUP_ALIGN]
		let fixed = a[i+POPUP_FIXED]

		position_popup(w, h, side, align, tx1, ty1, tx2, ty2)
		pr(tx1, tx2, side, align, x, y)

		// if popup doesn't fit the screen, first try to change its side
		// or alignment and relayout, and if that doesn't work, its offset.

		let d = 10
		let bw = screen_w
		let bh = screen_h

		let out_x1 = x < d
		let out_y1 = y < d
		let out_x2 = x + w > (bw - d)
		let out_y2 = y + h > (bh - d)

		let re
		if (side == POPUP_SIDE_BOTTOM && out_y2) {
			re = 1; side = POPUP_SIDE_TOP
		} else if (side == POPUP_SIDE_TOP && out_y1) {
			re = 1; side = POPUP_SIDE_BOTTOM
		} else if (side == POPUP_SIDE_RIGHT && out_x2) {
			re = 1; side = POPUP_SIDE_LEFT
		} else if (side == POPUP_SIDE_TOP && out_x1) {
			re = 1; side = POPUP_SIDE_BOTTOM
		}

		let vert =
			   side == POPUP_SIDE_BOTTOM
			|| side == POPUP_SIDE_TOP
			|| side == POPUP_SIDE_INNER_BOTTOM
			|| side == POPUP_SIDE_INNER_TOP

		if (align == POPUP_ALIGN_END && ((vert && out_x2) || (!vert && out_y2))) {
			re = 1; align = POPUP_ALIGN_START
		} else if (align == POPUP_ALIGN_START && ((vert && out_x1) || (!vert && out_y1))) {
			re = 1; align = POPUP_ALIGN_END
		}

		if (re)
			position_popup(w, h, side, align, tx1, ty1, tx2, ty2)

		// if nothing else works, adjust the offset to fit the screen.
		let ox2 = max(0, x + w - (bw - d))
		let ox1 = min(0, x)
		let oy2 = max(0, y + h - (bh - d))
		let oy1 = min(0, y)
		x -= ox1 ? ox1 : ox2
		y -= oy1 ? oy1 : oy2

		a[i+0] = x // + (fixed ? sx : 0) - spx
		a[i+1] = y // + (fixed ? sy : 0) - spy

	}

	ct_stack.pop()

}
}

position[CMD_TEXT] = function(a, i, axis, ct_x, ct_w) {
	a[i+0+axis] = ct_x
	a[i+2+axis] = ct_w
}

function position_all(axis) {
	reset_text()
	let s_w = axis ? screen_h : screen_w
	let i = 2
	let n = a.length
	while (i < n) {
		let cmd = a[i-1]
		let position_f = position[cmd]
		if (position_f) {
			let min_w = a[i+2+axis]
			position_f(a, i, axis, 0, max(min_w, s_w), 0)
		}
		i = get_next_ext_i(a, i)
	}
}

// ---------------------------------------------------------------------------

let hit_set = set() // {id}

let hit_state_map_freelist = map_freelist()
let hit_state_maps = map() // {id->map}

function hovers(id) {
	if (!id)
		return
	if (!hit_set.has(id))
		return
	let m = hit_state_maps.get(id)
	if (!m) {
		m = hit_state_map_freelist()
		hit_state_maps.set(id, m)
	}
	return m
}

function hit_rect(x, y, w, h) {
	return (
		(mx >= ct_x + x && mx < ct_x + x + w) &&
		(my >= ct_y + y && my < ct_y + y + h)
	)
}

function hit_box(a, i) {
	let x = a[i+0]
	let y = a[i+1]
	let w = a[i+2]
	let h = a[i+3]
	return hit_rect(x, y, w, h)
}

hit[CMD_TEXT] = function(a, i) {
	if (!hit_box(a, i))
		return
	hit_set.add(a[i+TEXT_ID])
	return true
}

function hit_ct(a, i) {

	if (!hit_box(a, i))
		return

	let ct_x0 = ct_x
	let ct_y0 = ct_y

	ct_x += a[i+0]
	ct_y += a[i+1]

	if (a[i-1] == CMD_SCROLLBOX) {
		ct_x += a[i+SB_SX+0]
		ct_y += a[i+SB_SX+1]
	}

	// hit direct children in reverse paint order.
	let ct_i = i
	let next_ext_i = get_next_ext_i(a, i)
	let end_i = a[next_ext_i-3] // prev_i
	i = a[end_i-3] // prev_i
	while (i > ct_i) {
		let cmd = a[i-1]
		if (cmd == CMD_END) {
			i = a[i] // start_i
			cmd = a[i-1]
		}
		let hit_f = hit[cmd]
		if (hit_f && hit_f(a, i)) {
			break
		}
		i = a[i-3] // prev_i
	}

	ct_x = ct_x0
	ct_y = ct_y0

	return true
}

hit[CMD_SCROLLBOX] = function(a, i) {
	let id = a[i+SB_ID]
	if (!id)
		return
	if (!hit_ct(a, i))
		return
	for (let axis = 0; axis < 2; axis++) {
		let [visible, tx, ty, tw, th] = scrollbar_rect(a, i, axis)
		if (!visible)
			continue
		if (!hit_rect(tx, ty, tw, th))
			continue
		let sbar_id = id+'.scrollbar'+axis
		hit_set.add(sbar_id)
	}
	return true
}

hit[CMD_H    ] = hit_ct
hit[CMD_V    ] = hit_ct
hit[CMD_STACK] = hit_ct

function hit_test_all() {

	reset_text()
	for (let m of hit_state_maps.values())
		hit_state_map_freelist(m)
	hit_state_maps.clear()
	hit_set.clear()

	if (mx == null)
		return

	// iterate layers in reverse order
	for (let j = a.layers.length-1; j >= 0; j--) {
		let layer = a.layers[j]
		// iterate layer ranges in reverse order
		for (let k = layer.length-2; k >= 0; k -= 2) {
			// layer cmd range: a[i0..i1-1]
			let i0 = layer[k]
			let i1 = layer[k+1]
			// iterate commands in current range in reverse order.
			let prev_i = i1-1
			if (prev_i < i0)
				continue
			let i = a[prev_i]
			while (1) {
				let cmd = a[i-1]
				if (cmd == CMD_END) {
					i = a[i] // start_i
					cmd = a[i-1]
				}
				let hit_f = hit[cmd]
				if (hit_f)
					if (hit_f(a, i))
						break
				if (i == i0+2)
					break
				i = a[i-3] // prev_i
			}
		}
	}
}

// ---------------------------------------------------------------------------

draw[CMD_H] = function(a, i) {

	ct_stack.push(i)

	let x = a[i+0] + a[i+MX1+0] + a[i+PX1+0]
	let y = a[i+1] + a[i+MX1+1] + a[i+PX1+1]
	let w = a[i+2]
	let h = a[i+3]

	cx.save()
	cx.translate(x, y)

	if (DEBUG) {
		cx.strokeStyle = color
		cx.beginPath()
		cx.rect(x, y, w, h)
		cx.stroke()
	}
}
draw[CMD_V    ] = draw[CMD_H]
draw[CMD_STACK] = draw[CMD_H]
draw[CMD_POPUP] = draw[CMD_H]

draw[CMD_TEXT] = function(a, i) {

	let x = a[i+0] + a[i+MX1+0] + a[i+PX1+0]
	let y = a[i+1] + a[i+MX1+1] + a[i+PX1+1]
	let w = a[i+2]
	let h = a[i+3]
	let s   = a[i+TEXT_S]
	let asc = a[i+TEXT_ASC]

	if (DEBUG) {
		cx.strokeStyle = color
		cx.beginPath()
		cx.rect(x, y, w, h)
		cx.stroke()
	}

	cx.textAlign = 'left'
	cx.fillStyle = color
	cx.fillText(s, x, y+asc)
}

let scrollbar_rect
{
let r = [false, 0, 0, 0, 0]
scrollbar_rect = function(a, i, axis) {
	let x  = a[i+0] + a[i+MX1+0] + a[i+PX1+0]
	let y  = a[i+1] + a[i+MX1+1] + a[i+PX1+1]
	let w  = a[i+2]
	let h  = a[i+3]
	let cw = a[i+SB_CW]
	let ch = a[i+SB_CW+1]
	let sx = a[i+SB_SX]
	let sy = a[i+SB_SX+1]
	sx = max(0, min(sx, cw - w))
	sy = max(0, min(sy, ch - h))
	let psx = sx / (cw - w)
	let psy = sy / (ch - h)
	let pw = w / cw
	let ph = h / ch
	let thickness = 10
	let visible, tx, ty, tw, th
	if (!axis) {
		visible = pw < 1
		if (visible) {
			tw = pw * w
			th = thickness
			tx = psx * (w - tw)
			ty = h - th
		}
	} else {
		visible = ph < 1
		if (visible) {
			th = ph * h
			tw = thickness
			ty = psy * (h - th)
			tx = w - tw
		}
	}
	r[0] = visible
	r[1] = x + tx
	r[2] = y + ty
	r[3] = tw
	r[4] = th
	return r
}
}

draw[CMD_SCROLLBOX] = function(a, i) {

	ct_stack.push(i)

	let x  = a[i+0] + a[i+MX1+1] + a[i+PX1+1]
	let y  = a[i+1] + a[i+MX1+1] + a[i+PX1+1]
	let w  = a[i+2]
	let h  = a[i+3]
	let cw = a[i+SB_CW]
	let ch = a[i+SB_CW+1]
	let sx = a[i+SB_SX]
	let sy = a[i+SB_SX+1]

	cx.save()
	cx.translate(x, y)

	cx.beginPath()
	cx.rect(0, 0, w, h)
	cx.clip()
	if (DEBUG) {
		cx.strokeStyle = color
		cx.stroke()
	}
	cx.translate(-sx, -sy)
}

draw[CMD_END] = function(a, end_i) {

	let i = ct_stack.pop()

	cx.restore()

	let cmd = a[i-1]
	if (cmd == CMD_SCROLLBOX) {
		let id = a[i+SB_ID]
		for (let axis = 0; axis < 2; axis++) {

			let [visible, tx, ty, tw, th] = scrollbar_rect(a, i, axis)
			if (!visible)
				continue

			let sbar_id = id+'.scrollbar'+axis
			let cs = captured(sbar_id)
			let hs = hovers(sbar_id)

			cx.beginPath()
			cx.rect(tx, ty, tw, th)
			cx.fillStyle = cs && 'green' || hs && 'red' || 'gray'
			cx.fill()

		}
	}
}

let border_paths; {

function T  (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y1); cx.lineTo(x2, y1) }
function R  (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y1); cx.lineTo(x2, y2) }
function B  (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y2); cx.lineTo(x1, y2) }
function L  (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y2); cx.lineTo(x1, y1) }
function TB (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y1); cx.lineTo(x2, y1); cx.moveTo(x2, y2); cx.lineTo(x1, y2) }
function RL (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y1); cx.lineTo(x2, y2); cx.moveTo(x1, y2); cx.lineTo(x1, y1) }
function TR (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y1); cx.lineTo(x2-r, y1); if (r) cx.arcTo(x2, y1, x2, y1+r, r); cx.lineTo(x2, y2) }
function RB (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y1); cx.lineTo(x2, y2-r); if (r) cx.arcTo(x2, y2, x2-r, y2, r); cx.lineTo(x1, y2) }
function BL (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y2); cx.lineTo(x1+r, y2); if (r) cx.arcTo(x1, y2, x1, y2-r, r); cx.lineTo(x1, y1) }
function LT (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y2); cx.lineTo(x1, y1+r); if (r) cx.arcTo(x1, y1, x1+r, y1, r); cx.lineTo(x2, y1) }
function TRB(cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y1); cx.lineTo(x2-r, y1); if (r) cx.arcTo(x2, y1, x2, y1+r, r); cx.lineTo(x2, y2-r); if (r) cx.arcTo(x2, y2, x2-r, y2, r); cx.lineTo(x1, y2) }
function RBL(cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y1); cx.lineTo(x2, y2-r); if (r) cx.arcTo(x2, y2, x2-r, y2, r); cx.lineTo(x1+r, y2); if (r) cx.arcTo(x1, y2, x1, y2-r, r); cx.lineTo(x1, y1) }
function BLT(cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y2); cx.lineTo(x1+r, y2); if (r) cx.arcTo(x1, y2, x1, y2-r, r); cx.lineTo(x1, y1+r); if (r) cx.arcTo(x1, y1, x1+r, y1, r); cx.lineTo(x2, y1) }
function LTR(cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y2); cx.lineTo(x1, y1+r); if (r) cx.arcTo(x1, y1, x1+r, y1, r); cx.lineTo(x2-r, y1); if (r) cx.arcTo(x2, y1, x2, y1+r, r); cx.lineTo(x2, y2) }

border_paths = [noop, T, R, TR, B, TB, RB, TRB, L, LT, RL, LTR, BL, BLT, RBL]
}

let c2d = CanvasRenderingContext2D.prototype
if (!c2d.roundRect) { // Firefox doesn't have it
	c2d.roundRect = function(x1, y1, w, h, r) {
		let x2 = x1 + w
		let y2 = y1 + h
		cx.moveTo(x2-r, y1); if (r) cx.arcTo(x2, y1, x2, y1+r, r)
		cx.lineTo(x2, y2-r); if (r) cx.arcTo(x2, y2, x2-r, y2, r)
		cx.lineTo(x1+r, y2); if (r) cx.arcTo(x1, y2, x1, y2-r, r)
		cx.lineTo(x1, y1+r); if (r) cx.arcTo(x1, y1, x1+r, y1, r)
		cx.closePath()
	}
}

function border_path(cx, x1, y1, x2, y2, sides, radius) {
	cx.beginPath()
	if (sides == BORDER_SIDE_ALL)
		if (!radius)
			cx.rect(x1, y1, x2-x1, y2-y1)
		else
			cx.roundRect(x1, y1, x2-x1, y2-y1, radius)
	else
		border_paths[sides](cx, x1, y1, x2, y2, radius)
}

let shadow_set
draw[CMD_SHADOW] = function(a, i) {
	cx.shadowColor   = a[i+0]
	cx.shadowBlur    = a[i+1]
	cx.shadowOffsetX = a[i+2]
	cx.shadowOffsetY = a[i+3]
	shadow_set = true
}

draw[CMD_RECT] = function(a, i) {
	let ct_i = ct_stack.at(-1)
	let px1 = a[ct_i+PX1+0]
	let py1 = a[ct_i+PX1+1]
	let px2 = a[ct_i+PX2+0]
	let py2 = a[ct_i+PX2+1]
	let mx1 = a[ct_i+MX1+0]
	let my1 = a[ct_i+MX1+1]
	let mx2 = a[ct_i+MX2+0]
	let my2 = a[ct_i+MX2+1]
	let x = -px1
	let y = -py1
	let w = a[ct_i+2] - mx1 - mx2
	let h = a[ct_i+3] - my1 - my2
	let bg_color      = a[i]
	let border_sides  = a[i+1]
	let border_color  = a[i+2]
	let border_radius = a[i+3]
	if (bg_color != null) {
		cx.fillStyle = bg_color
		border_path(cx, x, y, x + w, y + h, BORDER_SIDE_ALL, border_radius)
		cx.fill()
	}
	if (shadow_set) {
		cx.shadowBlur    = 0
		cx.shadowOffsetX = 0
		cx.shadowOffsetY = 0
		shadow_set = false
	}
	if (border_sides) {
		cx.strokeStyle = border_color
		cx.lineWidth = 1
		cx.lineCap = 'square'
		border_path(cx, x + .5, y + .5, x + w - .5, y + h - .5, border_sides, border_radius)
		cx.stroke()
	}
}

draw[CMD_COLOR] = function(a, i) {
	color = a[i]
}

draw[CMD_FONT] = set_font
draw[CMD_FONT_SIZE] = set_font_size

// ---------------------------------------------------------------------------

function draw_all() {
	reset_text()
	for (let layer of a.layers) {
		for (let k = 0, k_last = layer.length-2; k <= k_last; k += 2) {
			let i0 = layer[k+0]
			let i1 = layer[k+1]
			let i = i0 + 2
			while (i < i1) {
				let cmd = a[i-1]
				let draw_f = draw[cmd]
				if (draw_f)
					draw_f(a, i)
				i = a[i-2] // next_i
			}
		}
	}
}

function redraw_all() {
	a.length = 0
	for (let layer of a.layers)
		layer_clear(layer)
	reset_text()
	ui.push_layer_base()
	make_frame()
	ui.pop_layer()
	assert(!ct_stack.length, 'container not closed')
	assert(!layer_stack.length, 'layer not closed')
	id_state_gc()
	measure_all(0)
	position_all(0)
	measure_all(1)
	position_all(1)
	draw_all()
}

function pr_layer(a) {
	let i = 2
	let depth = 0
	let n = a.length
	while (i < n) {
		let cmd = a[i-1]
		if (cmd == CMD_END)
			depth--
		let indent = (' ').repeat(depth)
		let cmd_s = cmd_names[cmd]
		if (cmd < CMD_END) {
			let next_ext_i = a[i+NEXT_EXT_I]
			let next_ext_cmd_s = cmd_names[a[next_ext_i-1]]
			pr(indent + '(' + cmd_s + (next_ext_cmd_s ? ' > ' + next_ext_cmd_s : ''))
			depth++
		} else if (cmd == CMD_END) {
			pr(indent + ')')
		} else {
			pr(indent + cmd_s)
		}
		let next_i = a[i-2]
		i = next_i
	}
	assert(depth == 0)
}

// ---------------------------------------------------------------------------

function make_frame() {

	ui.color('white')
	ui.font('Arial')
	ui.font_size(30)

	ui.h(1, 20)
		ui.text('t1', 'Hello!')
		ui.stack(1)
			ui.rect('hsl(0deg 0% 16%)')
			ui.scrollbox('sb1', 1)
				ui.m(50 ,  50, 0, 0)
				ui.p(100, 100, 0, 0)
				ui.v(1, 20, 'c', 'c')
					// ui.bg('hsl(0deg 0% 16%)')
					ui.shadow('black', 5, 2, 2)
					ui.rect('blue', 1, 'hsl(0 0% 100%)', 20)
					// ui.padding(10, 10, 10, 10)
					ui.text('t2', '[Hello Hello Hello Hello Hello]', '[', 'c', 1)
					// ui.padding(10, 10, 10, 10)
					ui.text('t3', (max_frame_duration * 1000).dec(1)+' ms', '[', 'c', 1)
					ui.text('t4', (last_frame_duration * 1000).dec(1)+' ms', '[', 'c', 1)
					ui.push_layer_popup()
					ui.m(0, 0, 20, 0)
					ui.popup('p1', 'b')
						ui.rect('red', 1, 'hsl(0 0% 100%)', 5)
						ui.text('tp1', 'Wasup?')
					ui.end('popup')
					ui.pop_layer()
				ui.end('v')
			ui.end('scrollbox')
		ui.end('stack')
		ui.stack(1, 'c', 'c')
			ui.rect(null, 'blt', 'red', 10)
			// ui.margin (10, 10, 10, 10)
			// ui.padding(10, 10, 10, 10)
			ui.text('t4', 'Hello Again!', 'c', 'c', 1)
		ui.end('stack')
		ui.text('t3', '...and again.', 'c', 'c', 1)
	ui.end('h')

	// redraw()

}

// ---------------------------------------------------------------------------

let modules = {
	main: {
		type: 'tabs',
		tabs: [
			{type: 'module', name: 'module1'},
			{type: 'module', name: 'module2'},
		],
	},
	module1: {
		type: 'text',
		text: 'Hello!',
	},
}

let module = {}

module.tabs = function() {

	return tabs
}

module.module2 = function() {


}

}()) // module function
</script>
</body>
</html>
