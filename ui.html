<!DOCTYPE html>
<html>
<head>
<style>
* {
	box-sizing: border-box;
}
html, body {
	width: 100%;
	height: 100%;
	padding: 0;
	margin: 0;
	border: 0;
	overflow: hidden;
}
body {
	display: flex;
	position: relative;
	background: black;
}
.ui_canvas {
	position: absolute;
}
</style>
</head>
<body>
<canvas class=ui_canvas id=canvas></canvas>
<script>

(function () {
"use strict"
let G = window

/*

GOALS

- drag & drop UI designer
- reusable UI modules with controlled variations
- IMGUI with popups and layouting
- remote screen sharing with input routing

IMGUI

- drawing
	* z-index
	* text
	* bg-color
	* border
	* box-shadow
	- images (incl. svg?)
- layouting
	* min width & height
	* flexbox fr stretch
	* flexbox min-w/h grow
	* flexbox align
	* flexbox gap
	* stack
	* padding
	* margin
	* text min-w/h
	* popup layouting
	- word-wrapping
	- grid fr stretch
	- grid min-w/h grow
	- grid align
	- grid gap
	- transition animations
- mouse
	* hit-test rect
	* hit state
	* hit parents
	* capturing
	* capture state
	- drag & drop
- keyboard
	- focused widget
	- event bubbling
- text selection
	- drag-select with mouse
- text(area) input
	- put it behind the canvas with correct width & height
		- route keyboard events to it
		- redraw it on canvas with offset and selection

CHALLENGES

- input on a canvas
- textarea on a canvas
- webgl2 canvas on a 2d canvas
- word wrapping (our layout algo supports word-wrapping for horizontal text)
- rich text on a canvas (inline box model)

PROS vs WEB
- stateless i.e. reactive / IMGUI (but with layouting and z-index and no frame lag)
- simpler and far more productive layouting and styling models
- global z-index, allowing for:
	- relatively-positioned but painted-last popups
	- painted-last focus ring
- transition animations for in-layout objects, allowing for:
	- animated element moving, drag/drop and selection under/overlays
- streamable and replayable rendering, for sreen-sharing and remote interaction
- super-fast and memory-efficient with very low gc pressure between frames.
- complex widgets built with a combination of box-stacking and custom-drawing.

CONS vs WEB
- must reimplement:
	- text selection & clipboard ops
	- scrollbox
	- word-wrapping
	- inline layouting with:
		- u, b, i, strike, sub, sup, h1..6, p, br, hr, float
- no fancy typography:
	- no smart word-wrapping (Thai, auto-hyphenation)
	- no BiDi
	- no smart underline (interrupted by letter descenders)
-

*/

// utilities ------------------------------------------------------------------

G.isobject = e => e != null && typeof e == 'object' // includes arrays, HTMLElements, etc.
G.isarray = Array.isArray
G.isobj = t => isobject(t) && (t.constructor == Object || t.constructor === undefined)
G.isstr = s => typeof s == 'string'
G.isnum = n => typeof n == 'number'
G.isbool = b => typeof b == 'boolean'
G.isfunc = f => typeof f == 'function'

G.assert = function(ret, err, ...args) {
	if (ret == null || ret === false) {
		throw ((err && err.subst(...args) || 'assertion failed'))
	}
	return ret
}

G.pr = console.log
G.trace = console.trace

G.floor = Math.floor
G.ceil  = Math.ceil
G.round = Math.round
G.max   = Math.max
G.min   = Math.min
G.abs   = Math.abs

// NOTE: returns x1 if x1 < x0, which enables the idiom
// `a[clamp(i, 0, b.length-1)]` to return undefined when b is empty.
G.clamp = function(x, x0, x1) {
	return min(max(x, x0 ?? -1/0), x1 ?? 1/0)
}

Number.prototype.dec = Number.prototype.toFixed

G.num = function(s) {
	let x = parseFloat(s)
	return x != x ? undefined : x
}

// usage:
//	 '{1} of {0}'.subst(total, current)
//	 '{1} of {0}'.subst([total, current])
//	 '{1} of {0:foo:foos}'.subst([total, current])
//	 '{current} of {total}'.subst({'current': current, 'total': total})
String.prototype.subst = function(...args) {
	if (!args.length)
		return this.valueOf()
	if (isarray(args[0]))
		args = args[0]
	if (isobject(args[0]))
		args = args[0]
	return this.replace(/{(\w+)\:(\w+)\:(\w+)}/g, function(match, s, singular, plural) {
		let v = num(args[s])
		return v != null ? v + ' ' + (v > 1 ? plural : singular) : s
	}).replace(/{([\w\:]+)}/g, (match, s) => args[s])
}

String.prototype.starts = function(s, i) { return this.startsWith(s, i) }
String.prototype.ends   = function(s, i) { return this.endsWith(s, i) }
String.prototype.upper  = function() { return this.toUpperCase() }
String.prototype.lower  = function() { return this.toLowerCase() }

G.obj = () => Object.create(null)
G.set = (iter) => new Set(iter)
G.map = (iter) => new Map(iter)
G.array = (...args) => new Array(...args)

G.noop = function() {}

G.json = JSON.stringify

G.clock = function() { return performance.now() / 1000 }

EventTarget.prototype.on = function(event, f, on) {
	if (on == null)
		on = true
	if (on)
		this.addEventListener(event, f)
	else
		this.removeEventListener(event, f)
}

function hash32(s) {
	let hash = 0
	for (let i = 0, n = s.length; i < n; i++) {
		hash = ((hash << 5) - hash) + s.charCodeAt(i)
		hash |= 0 // convert to 32bit integer
	}
	return hash
}

function map_freelist() {
	let fl = []
	return function(m) {
		if (m) {
			m.clear()
			fl.push(m)
		} else {
			m = fl.pop()
			return m || map()
		}
	}
}

// when using capture_pointer(), setting the cursor for the element that
// is hovered doesn't work anymore, so use this hack instead.
{
let cursor_style
G.force_cursor = function(cursor) {
	if (cursor) {
		if (!cursor_style) {
			cursor_style = tag('style')
			cursor_style.unsafe_html = '* {cursor: '+cursor+' !important; }'
			root.add(cursor_style)
		} else {
			cursor_style.unsafe_html = '* {cursor: '+cursor+' !important; }'
		}
	} else if (cursor_style) {
		cursor_style.remove()
		cursor_style = null
	}
}
}

// ui module -----------------------------------------------------------------

G.ui = {}

G.DEBUG = 0

// canvas --------------------------------------------------------------------

let a = []

let dpr

function resize_canvas() {
	dpr = devicePixelRatio
	let window_w = window.innerWidth
	let window_h = window.innerHeight
	let screen_w = floor(window_w * dpr)
	let screen_h = floor(window_h * dpr)
	canvas.style.width  = screen_w / dpr + 'px'
	canvas.style.height = screen_h / dpr + 'px'
	canvas.width  = screen_w
	canvas.height = screen_h
	a.w = screen_w
	a.h = screen_h
	redraw()
}
let cx = canvas.getContext('2d')
let raf_id
let max_frame_duration = 0
let last_frame_duration = 0
function raf_redraw() {
	raf_id = null
	let t0 = clock()
	cx.clearRect(0, 0, canvas.width, canvas.height)
	redraw_all()
	last_frame_duration = clock() - t0
	if (max_frame_duration)
		max_frame_duration = max(last_frame_duration, max_frame_duration)
	else
		max_frame_duration = 0.000001
}
function redraw() {
	if (raf_id) return
	raf_id = requestAnimationFrame(raf_redraw)
}
resize_canvas()
window.on('resize', resize_canvas)

// input event handling ------------------------------------------------------

let mx, my, mx0, my0, down, captured_id
let clicked = false
let wheel_dy = 0
let trackpad = false

canvas.on('pointerdown', function(ev) {
	mx = ev.clientX * dpr
	my = ev.clientY * dpr
	if (ev.which == 1) {
		down = true
		this.setPointerCapture(ev.pointerId)
		hit_all()
		redraw()
	}
})

canvas.on('pointerup', function(ev) {
	mx = ev.clientX * dpr
	my = ev.clientY * dpr
	if (ev.which == 1) {
		down = false
		captured_id = null
		clicked = true
		this.releasePointerCapture(ev.pointerId)
		hit_all()
		redraw()
	}
})

canvas.on('pointermove', function(ev) {
	mx = ev.clientX * dpr
	my = ev.clientY * dpr
	hit_all()
	redraw()
})

canvas.on('pointerleave', function(ev) {
	mx = null
	my = null
	hit_all()
	redraw()
})

canvas.on('wheel', function(ev) {
	wheel_dy = ev.wheelDeltaY
	if (!wheel_dy)
		return
	trackpad = ev.wheelDeltaY === -ev.deltaY * 3
	mx = ev.clientX * dpr
	my = ev.clientY * dpr
	hit_all()
	redraw()
})

let capture_state = map()

function capture(id) {
	if (!id)
		return
	if (captured_id)
		return
	if (!down)
		return
	if (!hit_set.has(id))
		return
	captured_id = id
	capture_state.clear()
	mx0 = mx
	my0 = my
	return capture_state
}

function captured(id) {
	if (!id)
		return
	if (captured_id != id)
		return
	return capture_state
}

// layers --------------------------------------------------------------------

function layer_make(name) {
	let layer = [] // [popup1_i,...]
	layer.name = name
	return layer
}

function layer_clear(layer) {
	layer.length = 0
}

let layer_base  = layer_make('base')
let layer_popup = layer_make('popup')

a.layers = [layer_base, layer_popup]

let layer_stack = []
let layer

function push_layer(layer1, i) {
	if (layer1 != layer)
		layer1.push(i)
	if (layer)
		layer_stack.push(layer)
	layer = layer1
}

function pop_layer() {
	layer = layer_stack.pop()
}

// id state maps -------------------------------------------------------------

let id_state_map_freelist = map_freelist()
let id_state_maps = map() // {id->map}
let id_current_set = set() // {id}
let id_remove_set  = set() // {id}

function id_touch(id) {
	id_current_set.add(id)
	id_remove_set.delete(id)
}

function id_state(id) {
	if (!id)
		return
	id_touch(id)
	let m = id_state_maps.get(id)
	if (!m) {
		m = id_state_map_freelist()
		id_state_maps.set(id, m)
	}
	return m
}

function id_state_gc() {
	for (let id of id_remove_set) {
		let m = id_state_maps.get(id)
		id_state_maps.delete(id)
		id_state_map_freelist(m)
	}
	id_remove_set.clear()
	let empty = id_remove_set
	id_remove_set = id_current_set
	id_current_set = empty
}

// imgui command array -------------------------------------------------------

let cmd_names = []
let cmd_name_map = map()

function C(a, i) { return cmd_names[a[i-1]] }

let measure   = []
let position  = []
let translate = []
let draw      = []
let hit       = []

function cmd(name, is_ct) {
	let code = hash32(name)
	code = (is_ct ? -1 : 1) * abs(code)
	assert(!cmd_names[code], 'duplicate command code {0} for {1}', code, name)
	cmd_names[code] = name
	cmd_name_map.set(name, code)
	return code
}
function cmd_ct(name) {
	return cmd(name, true)
}

ui.widget = function(cmd_name, t, is_ct) {
	let _cmd = cmd(cmd_name, is_ct)
	measure   [_cmd] = t.measure
	position  [_cmd] = t.position
	translate [_cmd] = t.translate
	draw      [_cmd] = t.draw
	hit       [_cmd] = t.hit
	let create = t.create
	if (create) {
		function wrapper(...args) {
			return create(_cmd, ...args)
		}
		ui[cmd_name] = wrapper
		return wrapper
	} else {
		return _cmd
	}
}
ui.widget_ct = function(cmd_name, t) { return ui.widget(cmd_name, t, true) }

let color, font, font_size

function reset_all() {
	color = null
	font = null
	font_size = null
	reset_paddings()
}

function ui_cmd(cmd, ...args) {
	let i0 = a.length+2   // index of this cmd's arg#1
	let i1 = i0+args.length+3 // index of next cmd's arg#1
	a.push(i1, cmd, ...args, i0)
	return i0
}

let ct_stack = [] // [ct_i1,...]

function check_stacks() {
	if (ct_stack.length) {
		for (let i of ct_stack)
			pr(C(a, i), 'not closed')
		assert(false)
	}
	if (layer_stack.length) {
		for (let layer of layer_stack)
			pr('layer', layer.name, 'not closed')
		assert(false)
	}
}

const PX1        =  4
const PX2        =  6
const MX1        =  8
const MX2        = 10

const FR         = 12 // children of v,h: fraction from main-axis size.
const ALIGN      = 13 // all children: align v,h.
const NEXT_EXT_I = 15 // all containers: next command after this one's END command.
const S          = 16 // first index after the ui_cmd_box_ct header.

const FLEX_GAP      = S+0
const FLEX_TOTAL_FR = S+1

const ALIGN_STRETCH = 0
const ALIGN_START   = 1
const ALIGN_END     = 2
const ALIGN_CENTER  = 3

function parse_align(s) {
	if (s == 's') return ALIGN_STRETCH
	if (s == 'c') return ALIGN_CENTER
	if (s == 'l') return ALIGN_START
	if (s == 'r') return ALIGN_END
	if (s == '[') return ALIGN_START
	if (s == ']') return ALIGN_END
	if (s == 'stretch') return ALIGN_STRETCH
	if (s == 'center' ) return ALIGN_CENTER
	if (s == 'left'   ) return ALIGN_START
	if (s == 'right'  ) return ALIGN_END
	assert(false, 'invalid align {0}', s)
}

function parse_valign(s) {
	if (s == 's') return ALIGN_STRETCH
	if (s == 'c') return ALIGN_CENTER
	if (s == 't') return ALIGN_START
	if (s == 'b') return ALIGN_END
	if (s == '[') return ALIGN_START
	if (s == ']') return ALIGN_END
	if (s == 'stretch') return ALIGN_STRETCH
	if (s == 'center' ) return ALIGN_CENTER
	if (s == 'top'    ) return ALIGN_START
	if (s == 'bottom' ) return ALIGN_END
	assert(false, 'invalid valign {0}', s)
}

// paddings and margins, applied to the next box cmd and then they are reset.
let px1, px2, py1, py2
let mx1, mx2, my1, my2

ui.padding = function(_px1, _px2, _py1, _py2) {
	px1 = _px1 ?? 0
	px2 = _px2 ?? _px1 ?? 0
	py1 = _py1 ?? _px1 ?? 0
	py2 = _py2 ?? _py1 ?? _px1 ?? 0
}
ui.p = ui.padding

ui.margin = function(_mx1, _mx2, _my1, _my2) {
	mx1 = _mx1 ?? 0
	mx2 = _mx2 ?? _mx1 ?? 0
	my1 = _my1 ?? _mx1 ?? 0
	my2 = _my2 ?? _my1 ?? _mx1 ?? 0
}
ui.m = ui.margin

function reset_paddings() {
	px1 = 0
	py1 = 0
	px2 = 0
	py2 = 0
	mx1 = 0
	my1 = 0
	mx2 = 0
	my2 = 0
}

function ui_cmd_box(cmd, fr, align, valign, min_w, min_h, ...args) {
	let i = ui_cmd(cmd,
		0, // x
		0, // y
		min_w ?? 0,
		min_h ?? 0,
		px1, py1, px2, py2,
		mx1, my1, mx2, my2,
		fr ?? 1,
		parse_align  (align  ?? 's'),
		parse_valign (valign ?? 's'),
		...args
	)
	reset_paddings()
	return i
}

// NOTE: `ct` is short for container, which must end with ui.end().
function ui_cmd_box_ct(cmd, fr, align, valign, min_w, min_h, ...args) {
	let i = ui_cmd_box(cmd, fr, align, valign, min_w, min_h,
		0, // next_ext_i
		...args
	)
	ct_stack.push(i)
	return i
}

function ui_hv(cmd, fr, gap, align, valign, min_w, min_h) {
	ui_cmd_box_ct(cmd, fr, align, valign, min_w, min_h,
		gap ?? 0,
		0, // total_fr
	)
}

const CMD_H = cmd_ct('h')
const CMD_V = cmd_ct('v')

ui.h = function(...args) { ui_hv(CMD_H, ...args) }
ui.v = function(...args) { ui_hv(CMD_V, ...args) }

const STACK_ID = S+0

const CMD_STACK = cmd_ct('stack')
ui.stack = function(id, fr, align, valign, min_w, min_h) {
	return ui_cmd_box_ct(CMD_STACK, fr, align, valign, min_w, min_h,
		id)
}

const SB_OVERFLOW =  S+0 // overflow x,y
const SB_CW       =  S+2 // content w,h
const SB_ID       =  S+4
const SB_SX       =  S+5 // scroll x,y

const CMD_SCROLLBOX = cmd_ct('scrollbox')
ui.scrollbox = function(id, fr, overflow_x, overflow_y, align, valign, min_w, min_h, sx, sy) {

	let ss = id_state(id)
	sx = sx ?? (ss ? ss.get('scroll_x') : 0)
	sy = sy ?? (ss ? ss.get('scroll_y') : 0)

	let i = ui_cmd_box_ct(CMD_SCROLLBOX, fr, align, valign, 0, 0,
		overflow_x ?? 'auto',
		overflow_y ?? 'auto',
		min_w ?? 0, // swapped with content w on `end`
		min_h ?? 0, // swapped with content h on `end`
		id,
		sx ?? 0, // scroll x
		sy ?? 0, // scroll y
	)
	if (ss) {
		ss.set('scroll_x', sx)
		ss.set('scroll_y', sy)
	}
}

const POPUP_SIDE_CENTER       = 0 // only POPUP_SIDE_INNER_CENTER is valid!
const POPUP_SIDE_LEFT         = 1
const POPUP_SIDE_RIGHT        = 2
const POPUP_SIDE_TOP          = 3
const POPUP_SIDE_BOTTOM       = 4
const POPUP_INNER             = 8 // own bit!
const POPUP_SIDE_INNER_CENTER = POPUP_INNER + POPUP_SIDE_CENTER
const POPUP_SIDE_INNER_LEFT   = POPUP_INNER + POPUP_SIDE_LEFT
const POPUP_SIDE_INNER_RIGHT  = POPUP_INNER + POPUP_SIDE_RIGHT
const POPUP_SIDE_INNER_TOP    = POPUP_INNER + POPUP_SIDE_TOP
const POPUP_SIDE_INNER_BOTTOM = POPUP_INNER + POPUP_SIDE_BOTTOM

const POPUP_ALIGN_CENTER = 0
const POPUP_ALIGN_START  = 1
const POPUP_ALIGN_END    = 2

function popup_parse_side(s) {
	if (s == '['           ) return POPUP_SIDE_LEFT
	if (s == ']'           ) return POPUP_SIDE_RIGHT
	if (s == 'l'           ) return POPUP_SIDE_LEFT
	if (s == 'r'           ) return POPUP_SIDE_RIGHT
	if (s == 't'           ) return POPUP_SIDE_TOP
	if (s == 'b'           ) return POPUP_SIDE_BOTTOM
	if (s == 'ic'          ) return POPUP_SIDE_INNER_CENTER
	if (s == 'il'          ) return POPUP_SIDE_INNER_LEFT
	if (s == 'ir'          ) return POPUP_SIDE_INNER_RIGHT
	if (s == 'it'          ) return POPUP_SIDE_INNER_TOP
	if (s == 'ib'          ) return POPUP_SIDE_INNER_BOTTOM
	if (s == 'left'        ) return POPUP_SIDE_LEFT
	if (s == 'right'       ) return POPUP_SIDE_RIGHT
	if (s == 'top'         ) return POPUP_SIDE_TOP
	if (s == 'bottom'      ) return POPUP_SIDE_BOTTOM
	if (s == 'inner-center') return POPUP_SIDE_INNER_CENTER
	if (s == 'inner-left'  ) return POPUP_SIDE_INNER_LEFT
	if (s == 'inner-right' ) return POPUP_SIDE_INNER_RIGHT
	if (s == 'inner-top'   ) return POPUP_SIDE_INNER_TOP
	if (s == 'inner-bottom') return POPUP_SIDE_INNER_BOTTOM
	assert(false, 'invalid popup side {0}', s)
}

function popup_parse_align(s) {
	if (s == 'c'     ) return POPUP_ALIGN_CENTER
	if (s == '['     ) return POPUP_ALIGN_START
	if (s == ']'     ) return POPUP_ALIGN_END
	if (s == 'center') return POPUP_ALIGN_CENTER
	if (s == 'start' ) return POPUP_ALIGN_START
	if (s == 'end'   ) return POPUP_ALIGN_END
	assert(false, 'invalid align {0}', s)
}

const POPUP_ID        = S+0
const POPUP_LAYER     = S+1
const POPUP_SIDE      = S+2
const POPUP_ALIGN     = S+3
const POPUP_FIXED     = S+4
const POPUP_FONT      = S+5
const POPUP_FONT_SIZE = S+6
const POPUP_COLOR     = S+7

const CMD_POPUP = cmd_ct('popup')
ui.popup = function(id, layer1, side, align, min_w, min_h, fixed) {
	layer1 = layer1 || layer
	// TODO: fr, align, valign are not used. find a way to remove them.
	let i = ui_cmd_box_ct(CMD_POPUP, 0, 's', 's', min_w, min_h,
		id,
		layer1,
		popup_parse_side(side ?? 't'),
		popup_parse_align(align ?? 'c'),
		fixed,
		// inherited state
		font,
		font_size,
		color,
	)
	push_layer(layer1, i)
}

const CMD_END = cmd('end')
ui.end = function(cmd_name) {
	let i = assert(ct_stack.pop(), 'end command outside container')
	if (cmd_name) {
		let cmd1 = assert(cmd_name_map.get(cmd_name))
		let cmd0 = a[i-1]
		assert(cmd0 == cmd1)
	}
	let end_i = ui_cmd(CMD_END, i)
	a[i+NEXT_EXT_I] = a[end_i-2] // next_i

	if (a[i-1] == CMD_POPUP)
		pop_layer()
}

const BORDER_SIDE_T = 1
const BORDER_SIDE_R = 2
const BORDER_SIDE_B = 4
const BORDER_SIDE_L = 8
const BORDER_SIDE_ALL = 15

function parse_border_sides(s) {
	if (!s) // 0, null, undefined
		return 0
	if (s == true) // true, 1
		return BORDER_SIDE_ALL
	return (
		(s.includes('l') ? BORDER_SIDE_L : 0) +
		(s.includes('r') ? BORDER_SIDE_R : 0) +
		(s.includes('t') ? BORDER_SIDE_T : 0) +
		(s.includes('b') ? BORDER_SIDE_B : 0)
	)
}

const BB_ID = 0

const CMD_BB = cmd('bb') // border-background
ui.bb = function(id, bg_color, sides, border_color, border_radius) {
	let ct_i = assert(ct_stack.at(-1), 'bb outside container')
	ui_cmd(CMD_BB, id, ct_i, bg_color, parse_border_sides(sides), border_color, border_radius)
}

const CMD_SHADOW = cmd('shadow')
ui.shadow = function(color, blur, x, y) {
	ui_cmd(CMD_SHADOW, color, blur, x, y)
}

const TEXT_ASC = S-1
const TEXT_ID  = S+0
const TEXT_S   = S+1

const CMD_TEXT = cmd('text')
ui.text = function(id, s, align, valign, fr) {
	// NOTE: min_w and min_h are measured, not given.
	ui_cmd_box(CMD_TEXT, fr ?? 0, align ?? '[', valign ?? 'c', 0, 0,
		0, // ascent
		id,
		s,
	)
}

const CMD_COLOR = cmd('color')
ui.color = function(s) {
	if (color == s) return
	ui_cmd(CMD_COLOR, s)
	color = s
}

const CMD_FONT = cmd('font')
ui.font = function(s) {
	if (font == s) return
	ui_cmd(CMD_FONT, s)
	font = s
}

const CMD_FONT_SIZE = cmd('font_size')
ui.font_size = function(s) {
	if (font_size == s) return
	ui_cmd(CMD_FONT_SIZE, s)
	font_size = s
}

function set_font(a, i) {
	font = a[i]
	cx.font = font_size + 'px ' + font
}

function set_font_size(a, i) {
	font_size = a[i]
	cx.font = font_size + 'px ' + font
}

function get_next_ext_i(a, i) {
	let cmd = a[i-1]
	if (cmd < 0) // container
		return a[i+NEXT_EXT_I]
	return a[i-2] // next_i
}

// measuring phase (per-axis) ------------------------------------------------

// calculate a[i+2]=min_w (for axis=0) or a[i+3]=min_h (for axis=1) of all boxes
// by walking the container tree bottom-up (non-recursive, uses ct_stack).
// the minimum dimensions include margins and paddings.

function is_main_axis(cmd, axis) {
	return (
		(cmd == CMD_V ? 1 : 2) == axis ||
		(cmd == CMD_H ? 0 : 2) == axis
	)
}

function paddings(a, i, axis) {
	return a[i+MX1+axis] + a[i+MX2+axis] + a[i+PX1+axis] + a[i+PX2+axis]
}

function add_ct_min_wh(a, axis, w, fr) {
	let i = ct_stack.at(-1)
	if (i == null) // root ct
		return
	let cmd = a[i-1]
	let main_axis = is_main_axis(cmd, axis)
	let min_w = a[i+2+axis]
	if (main_axis) {
		a[i+FLEX_TOTAL_FR] += fr
		let gap = a[i+FLEX_GAP]
		a[i+2+axis] = min_w + w + gap
	} else {
		a[i+2+axis] = max(min_w, w)
	}
}

measure[CMD_FONT] = set_font
measure[CMD_FONT_SIZE] = set_font_size

measure[CMD_TEXT] = function(a, i, axis) {
	let fr = a[i+FR]
	if (!axis) { // measure once
		let s = a[i+TEXT_S]
		let m = cx.measureText(s)
		let asc = m.fontBoundingBoxAscent
		let dsc = m.fontBoundingBoxDescent
		a[i+2] = ceil(m.width) + paddings(a, i, 0)
		a[i+3] = ceil(asc+dsc) + paddings(a, i, 1)
		a[i+TEXT_ASC] = round(asc)
	}
	let w = a[i+2+axis]
	add_ct_min_wh(a, axis, w, fr)
}

function ct_stack_push(a, i) {
	ct_stack.push(i)
}

measure[CMD_H        ] = ct_stack_push
measure[CMD_V        ] = ct_stack_push
measure[CMD_STACK    ] = ct_stack_push
measure[CMD_SCROLLBOX] = ct_stack_push
measure[CMD_POPUP    ] = ct_stack_push

measure[CMD_END] = function(a, _, axis) {
	let i = assert(ct_stack.pop(), 'end command outside a container')
	let p = max(0, paddings(a, i, axis))
	let cmd = a[i-1]
	if (cmd == CMD_SCROLLBOX) {
		let co_min_w = a[i+2+axis] // content min_w
		let sb_min_w = a[i+SB_CW+axis] + p // scrollbox min_w
		a[i+SB_CW+axis] = co_min_w
		a[i+2+axis] = sb_min_w
		let fr = a[i+FR]
		add_ct_min_wh(a, axis, sb_min_w, fr)
	} else if (cmd == CMD_POPUP) {
		a[i+2+axis] += p
		// popups don't affect their target's layout so no add_ct_min_wh() call.
	} else {
		let main_axis = is_main_axis(cmd, axis)
		if (main_axis)
			a[i+2+axis] = max(0, a[i+2+axis] - a[i+FLEX_GAP]) // remove last element's gap
		a[i+2+axis] += p
		let min_w = a[i+2+axis]
		let fr    = a[i+FR]
		add_ct_min_wh(a, axis, min_w, fr)
	}
}

function measure_all(axis) {
	check_stacks()
	reset_all()
	let i = 2
	let n = a.length
	while (i < n) {
		let cmd    = a[i-1]
		let next_i = a[i-2]
		let measure_f = measure[cmd]
		if (measure_f)
			measure_f(a, i, axis)
		i = next_i
	}
	check_stacks()
}

// positioning phase (per-axis) ----------------------------------------------

// calculate a[i+0]=x, a[i+2]=w (for axis=0) or a[i+1]=y, a[i+3]=h (for axis=1)
// of all boxes by walking the container tree top-down, and using different
// positioning algorithms based on container type (recursive).
// the resulting boxes at a[i+0..3] exclude margins and paddings.
// scrolling and popup positioning is done later.

position[CMD_TEXT] = function(a, i, axis, x, w) {
	a[i+0+axis] = x
	a[i+2+axis] = w
}

function position_box(position_f, a, i, axis, ct_x, ct_w) {

	// outer-box (ct_x, ct_w) -> inner-box (x, w).
	let mpl = a[i+MX1+axis] + a[i+PX1+axis]
	let mpr = a[i+MX2+axis] + a[i+PX2+axis]
	let x = ct_x + mpl
	let w = ct_w - (mpl + mpr)

	position_f(a, i, axis, x, w)
}

function position_children_cross_axis(a, i, axis, sx, sw) {

	i = a[i-2] // next_i
	while (a[i-1] != CMD_END) {

		let cmd = a[i-1]
		let position_f = position[cmd]

		if (position_f) {

			let min_w = a[i+2+axis]
			let align = a[i+ALIGN+axis]

			// stretch or align the item on the cross-axis.
			let x = sx
			let w = align == ALIGN_STRETCH ? sw : min_w
			if (align == ALIGN_END)
				x = sx + sw - w
			else if (align == ALIGN_CENTER)
				x = round(sx + (sw - w) / 2)

			// position item's children recursively.
			position_box(position_f, a, i, axis, x, w)

		}

		i = get_next_ext_i(a, i)
	}
}

function position_flex(a, i, axis, sx, sw) {

	a[i+0+axis] = sx
	a[i+2+axis] = sw

	if (is_main_axis(a[i-1], axis)) {

		let next_i   = a[i-2]
		let gap      = a[i+FLEX_GAP]
		let total_fr = a[i+FLEX_TOTAL_FR]

		// compute total gap.
		let gap_w = 0
		if (gap) {
			let n = 0
			let i = next_i
			while (a[i-1] != CMD_END) {
				if (position[a[i-1]])
					n++
				i = get_next_ext_i(a, i)
			}
			gap_w = max(0, (n - 1) * gap)
		}

		let total_w = sw - gap_w

		// compute total overflow width and total free width.
		let total_overflow_w = 0
		let total_free_w     = 0
		i = next_i
		while (a[i-1] != CMD_END) {

			let cmd = a[i-1]
			if (position[cmd]) {

				let min_w = a[i+2+axis]
				let fr    = a[i+FR]

				let flex_w = total_w * max(0, fr) / total_fr
				let overflow_w = max(0, min_w - flex_w)
				let free_w = max(0, flex_w - min_w)
				total_overflow_w += overflow_w
				total_free_w     += free_w

			}

			i = get_next_ext_i(a, i)
		}

		// distribute the overflow to children which have free space to
		// take it. each child shrinks to take in the percent of the overflow
		// equal to the child's percent of free space.
		i = next_i
		while (a[i-1] != CMD_END) {

			let cmd = a[i-1]
			let position_f = position[cmd]

			if (position_f) {

				let min_w = a[i+2+axis]
				let fr    = a[i+FR]
				let align = a[i+ALIGN+axis]

				// compute item's stretched width.
				let flex_w = total_w * fr / total_fr
				let sw
				if (min_w > flex_w) { // overflow
					sw = min_w
				} else {
					let free_w = flex_w - min_w
					let free_p = free_w / total_free_w
					let shrink_w = total_overflow_w * free_p
					if (shrink_w != shrink_w) // total_free_w == 0
						shrink_w = 0
					sw = floor(flex_w - shrink_w)
				}

				// TODO: check if this is the last element and if it is,
				// set `sw = total_w - sx` so that it eats up all rounding errors.

				// align the item inside the stretched segment defined by (sx, sw).
				let x = sx
				let w = align == ALIGN_STRETCH ? sw : min_w
				if (align == ALIGN_END)
					x = sx + sw - w
				else if (align == ALIGN_CENTER)
					x = round(sx + (sw - w) / 2)

				// position item's children recursively.
				position_box(position_f, a, i, axis, x, w)

				sw += gap
				sx += sw

			}

			i = get_next_ext_i(a, i)
		}

	} else {

		position_children_cross_axis(a, i, axis, sx, sw)

	}

}
position[CMD_H] = position_flex
position[CMD_V] = position_flex

position[CMD_STACK] = function(a, i, axis, x, w) {
	a[i+0+axis] = x
	a[i+2+axis] = w
	position_children_cross_axis(a, i, axis, x, w)
}

// NOTE: scrolling is done later.
position[CMD_SCROLLBOX] = function(a, i, axis, x, w) {
	a[i+0+axis] = x
	a[i+2+axis] = w
	let content_w = a[i+SB_CW+axis]
	position_children_cross_axis(a, i, axis, x, max(content_w, w))
}

// NOTE: popup positioning is done later.
position[CMD_POPUP] = function(a, i, axis) {
	let min_w = a[i+2+axis]
	position_children_cross_axis(a, i, axis, 0, min_w)
}

function position_all(axis) {
	let ct_w = axis ? a.h : a.w
	let i = 2
	let cmd = a[i-1]
	let min_w = a[i+2+axis]
	let position_f = position[cmd]
	position_box(position_f, a, i, axis, 0, max(min_w, ct_w))
}

// translation phase ---------------------------------------------------------

// do scrolling and popup positioning and offset all boxes (top-down, recursive).

translate[CMD_TEXT] = function(a, i, dx, dy) {
	a[i+0] += dx
	a[i+1] += dy
}

function translate_children(a, i, dx, dy) {
	let ct_i = i
	i = a[i-2] // next_i
	while (a[i-1] != CMD_END) {
		let cmd = a[i-1]
		let next_ext_i = get_next_ext_i(a, i)
		let translate_f = translate[cmd]
		if (translate_f)
			translate_f(a, i, dx, dy, ct_i)
		i = next_ext_i
	}
}

function translate_ct(a, i, dx, dy) {
	a[i+0] += dx
	a[i+1] += dy
	translate_children(a, i, dx, dy)
}

translate[CMD_H    ] = translate_ct
translate[CMD_V    ] = translate_ct
translate[CMD_STACK] = translate_ct

translate[CMD_SCROLLBOX] = function(a, i, dx, dy) {

	let x  = a[i+0] + dx
	let y  = a[i+1] + dy
	let w  = a[i+2]
	let h  = a[i+3]
	let cw = a[i+SB_CW+0]
	let ch = a[i+SB_CW+1]
	let sx = a[i+SB_SX+0]
	let sy = a[i+SB_SX+1]

	a[i+0] = x
	a[i+1] = y

	sx = max(0, min(sx, cw - w))
	sy = max(0, min(sy, ch - h))

	let psx = sx / (cw - w)
	let psy = sy / (ch - h)

	let id = a[i+SB_ID]
	if (id) {
		for (let axis = 0; axis < 2; axis++) {

			let [visible, tx, ty, tw, th] = scrollbar_rect(a, i, axis)
			if (!visible)
				continue

			if (axis && wheel_dy) {
				let sy0 = id_state(id).get('scroll_y') ?? 0
				sy = clamp(sy - wheel_dy, 0, h - th)
				id_state(id).set('scroll_y', sy)
				a[i+SB_SX+1] = sy
			}

			let sbar_id = id+'.scrollbar'+axis
			let cs = captured(sbar_id)
			if (cs) {
				if (!axis) {
					let psx0 = cs.get('ps0')
					let dpsx = (mx - mx0) / (w - tw)
					sx = clamp(psx0 + dpsx, 0, 1) * (cw - w)
					id_state(id).set('scroll_x', sx)
					a[i+SB_SX+0] = sx
				} else {
					let psy0 = cs.get('ps0')
					let dpsy = (my - my0) / (h - th)
					sy = clamp(psy0 + dpsy, 0, 1) * (ch - h)
					id_state(id).set('scroll_y', sy)
					a[i+SB_SX+1] = sy
				}
				break
			} else {
				let hs = hovers(sbar_id)
				if (!hs)
					continue
				let cs = capture(sbar_id)
				if (!cs)
					continue
				cs.set('ps0', !axis ? psx : psy)
			}
		}
	}

	translate_children(a, i, dx - sx, dy - sy)

}

{
let x, y
function position_popup(w, h, side, align, tx1, ty1, tx2, ty2) {

	let tw = tx2 - tx1
	let th = ty2 - ty1

	if (side == POPUP_SIDE_RIGHT) {
		;[x, y] = [tx2, ty1]
	} else if (side == POPUP_SIDE_LEFT) {
		;[x, y] = [tx1 - w, ty1]
	} else if (side == POPUP_SIDE_TOP) {
		;[x, y] = [tx1, ty1 - h]
	} else if (side == POPUP_SIDE_BOTTOM) {
		;[x, y] = [tx1, ty2]
	} else if (side == POPUP_SIDE_INNER_RIGHT) {
		;[x, y] = [tx2 - w, ty1]
	} else if (side == POPUP_SIDE_INNER_LEFT) {
		;[x, y] = [tx1, ty1]
	} else if (side == POPUP_SIDE_INNER_TOP) {
		;[x, y] = [tx1, ty1]
	} else if (side == POPUP_SIDE_INNER_BOTTOM) {
		;[x, y] = [tx1, ty2 - h]
	} else if (side == POPUP_SIDE_INNER_CENTER) {
		;[x, y] = [
			tx1 + round((tw - w) / 2),
			ty1 + round((th - h) / 2)
		]
	} else {
		assert(false)
	}

	let sd = side & ~POPUP_INNER
	let sdx = sd == POPUP_SIDE_LEFT || sd == POPUP_SIDE_RIGHT
	let sdy = sd == POPUP_SIDE_TOP  || sd == POPUP_SIDE_BOTTOM
	if (align == POPUP_ALIGN_CENTER && sdy)
		x = x + round((tw - w) / 2)
	else if (align == POPUP_ALIGN_CENTER && sdx)
		y = y + round((th - h) / 2)
	else if (align == POPUP_ALIGN_END && sdy)
		x = x + tw - w
	else if (align == POPUP_ALIGN_END && sdx)
		y = y + th - h
}
translate[CMD_POPUP] = function(a, i, dx, dy, ct_i) {

	let tx1 = a[ct_i+0] - a[ct_i+PX1+0]
	let ty1 = a[ct_i+1] - a[ct_i+PX1+1]
	let tx2 = a[ct_i+2] + tx1 + a[ct_i+PX2+0]
	let ty2 = a[ct_i+3] + ty1 + a[ct_i+PX2+1]

	let w     = a[i+2]
	let h     = a[i+3]
	let side  = a[i+POPUP_SIDE]
	let align = a[i+POPUP_ALIGN]
	let fixed = a[i+POPUP_FIXED] // TODO: use this!

	position_popup(w, h, side, align, tx1, ty1, tx2, ty2)

	// if popup doesn't fit the screen, first try to change its side
	// or alignment and relayout, and if that doesn't work, its offset.

	let d = 10
	let bw = a.w
	let bh = a.h

	let out_x1 = x < d
	let out_y1 = y < d
	let out_x2 = x + w > (bw - d)
	let out_y2 = y + h > (bh - d)

	let re
	if (side == POPUP_SIDE_BOTTOM && out_y2) {
		re = 1; side = POPUP_SIDE_TOP
	} else if (side == POPUP_SIDE_TOP && out_y1) {
		re = 1; side = POPUP_SIDE_BOTTOM
	} else if (side == POPUP_SIDE_RIGHT && out_x2) {
		re = 1; side = POPUP_SIDE_LEFT
	} else if (side == POPUP_SIDE_TOP && out_x1) {
		re = 1; side = POPUP_SIDE_BOTTOM
	}

	let vert =
			side == POPUP_SIDE_BOTTOM
		|| side == POPUP_SIDE_TOP
		|| side == POPUP_SIDE_INNER_BOTTOM
		|| side == POPUP_SIDE_INNER_TOP

	if (align == POPUP_ALIGN_END && ((vert && out_x2) || (!vert && out_y2))) {
		re = 1; align = POPUP_ALIGN_START
	} else if (align == POPUP_ALIGN_START && ((vert && out_x1) || (!vert && out_y1))) {
		re = 1; align = POPUP_ALIGN_END
	}

	if (re)
		position_popup(w, h, side, align, tx1, ty1, tx2, ty2)

	// if nothing else works, adjust the offset to fit the screen.
	let ox2 = max(0, x + w - (bw - d))
	let ox1 = min(0, x)
	let oy2 = max(0, y + h - (bh - d))
	let oy1 = min(0, y)
	x -= ox1 ? ox1 : ox2
	y -= oy1 ? oy1 : oy2

	a[i+0] = x
	a[i+1] = y

	translate_children(a, i, x, y)

}
}

function translate_all() {
	let i = 2
	let cmd = a[i-1]
	let translate_f = translate[cmd]
	translate_f(a, i, 0, 0)
}

// drawing phase -------------------------------------------------------------

draw[CMD_POPUP] = function(a, i) {

	let popup_layer = a[i+POPUP_LAYER]
	if (popup_layer != layer)
		return true

	font      = a[i+POPUP_FONT]
	font_size = a[i+POPUP_FONT_SIZE]
	color     = a[i+POPUP_COLOR]

	cx.font = font_size + 'px ' + font
}

draw[CMD_TEXT] = function(a, i) {

	let x   = a[i+0]
	let y   = a[i+1]
	let s   = a[i+TEXT_S]
	let asc = a[i+TEXT_ASC]

	cx.textAlign = 'left'
	cx.fillStyle = color
	cx.fillText(s, x, y+asc)

	draw_debug_box(a, i)
}

let scrollbar_rect
{
let r = [false, 0, 0, 0, 0]
scrollbar_rect = function(a, i, axis) {
	let x  = a[i+0]
	let y  = a[i+1]
	let w  = a[i+2]
	let h  = a[i+3]
	let cw = a[i+SB_CW+0]
	let ch = a[i+SB_CW+1]
	let sx = a[i+SB_SX+0]
	let sy = a[i+SB_SX+1]
	sx = max(0, min(sx, cw - w))
	sy = max(0, min(sy, ch - h))
	let psx = sx / (cw - w)
	let psy = sy / (ch - h)
	let pw = w / cw
	let ph = h / ch
	let thickness = 10
	let visible, tx, ty, tw, th
	let h_visible = pw < 1
	let v_visible = ph < 1
	let both_visible = h_visible && v_visible && 1 || 0
	if (!axis) {
		visible = h_visible
		if (visible) {
			let bw = w - both_visible * thickness
			tw = pw * bw
			th = thickness
			tx = psx * (bw - tw)
			ty = h - th
		}
	} else {
		visible = v_visible
		if (visible) {
			let bh = h - both_visible * thickness
			th = ph * bh
			tw = thickness
			ty = psy * (bh - th)
			tx = w - tw
		}
	}
	r[0] = visible
	r[1] = x + tx
	r[2] = y + ty
	r[3] = tw
	r[4] = th
	return r
}
}

draw[CMD_SCROLLBOX] = function(a, i) {

	let x = a[i+0]
	let y = a[i+1]
	let w = a[i+2]
	let h = a[i+3]

	cx.save()
	cx.beginPath()
	cx.rect(x, y, w, h)
	cx.clip()
}

draw[CMD_END] = function(a, end_i) {

	let i = a[end_i]
	if (a[i-1] == CMD_SCROLLBOX)
		cx.restore()

	if (a[i-1] == CMD_SCROLLBOX) {
		let id = a[i+SB_ID]
		for (let axis = 0; axis < 2; axis++) {

			let [visible, tx, ty, tw, th] = scrollbar_rect(a, i, axis)
			if (!visible)
				continue

			let sbar_id = id+'.scrollbar'+axis
			let cs = captured(sbar_id)
			let hs = hovers(sbar_id)

			cx.beginPath()
			cx.rect(tx, ty, tw, th)
			cx.fillStyle = cs && 'green' || hs && 'red' || 'gray'
			cx.fill()

		}
	}

	draw_debug_box(a, i)
}

let border_paths; {

function T  (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y1); cx.lineTo(x2, y1) }
function R  (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y1); cx.lineTo(x2, y2) }
function B  (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y2); cx.lineTo(x1, y2) }
function L  (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y2); cx.lineTo(x1, y1) }
function TB (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y1); cx.lineTo(x2, y1); cx.moveTo(x2, y2); cx.lineTo(x1, y2) }
function RL (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y1); cx.lineTo(x2, y2); cx.moveTo(x1, y2); cx.lineTo(x1, y1) }
function TR (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y1); cx.lineTo(x2-r, y1); if (r) cx.arcTo(x2, y1, x2, y1+r, r); cx.lineTo(x2, y2) }
function RB (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y1); cx.lineTo(x2, y2-r); if (r) cx.arcTo(x2, y2, x2-r, y2, r); cx.lineTo(x1, y2) }
function BL (cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y2); cx.lineTo(x1+r, y2); if (r) cx.arcTo(x1, y2, x1, y2-r, r); cx.lineTo(x1, y1) }
function LT (cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y2); cx.lineTo(x1, y1+r); if (r) cx.arcTo(x1, y1, x1+r, y1, r); cx.lineTo(x2, y1) }
function TRB(cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y1); cx.lineTo(x2-r, y1); if (r) cx.arcTo(x2, y1, x2, y1+r, r); cx.lineTo(x2, y2-r); if (r) cx.arcTo(x2, y2, x2-r, y2, r); cx.lineTo(x1, y2) }
function RBL(cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y1); cx.lineTo(x2, y2-r); if (r) cx.arcTo(x2, y2, x2-r, y2, r); cx.lineTo(x1+r, y2); if (r) cx.arcTo(x1, y2, x1, y2-r, r); cx.lineTo(x1, y1) }
function BLT(cx, x1, y1, x2, y2, r) { cx.moveTo(x2, y2); cx.lineTo(x1+r, y2); if (r) cx.arcTo(x1, y2, x1, y2-r, r); cx.lineTo(x1, y1+r); if (r) cx.arcTo(x1, y1, x1+r, y1, r); cx.lineTo(x2, y1) }
function LTR(cx, x1, y1, x2, y2, r) { cx.moveTo(x1, y2); cx.lineTo(x1, y1+r); if (r) cx.arcTo(x1, y1, x1+r, y1, r); cx.lineTo(x2-r, y1); if (r) cx.arcTo(x2, y1, x2, y1+r, r); cx.lineTo(x2, y2) }

border_paths = [noop, T, R, TR, B, TB, RB, TRB, L, LT, RL, LTR, BL, BLT, RBL]
}

let c2d = CanvasRenderingContext2D.prototype
if (!c2d.roundRect) { // Firefox doesn't have it
	c2d.roundRect = function(x1, y1, w, h, r) {
		let x2 = x1 + w
		let y2 = y1 + h
		cx.moveTo(x2-r, y1); if (r) cx.arcTo(x2, y1, x2, y1+r, r)
		cx.lineTo(x2, y2-r); if (r) cx.arcTo(x2, y2, x2-r, y2, r)
		cx.lineTo(x1+r, y2); if (r) cx.arcTo(x1, y2, x1, y2-r, r)
		cx.lineTo(x1, y1+r); if (r) cx.arcTo(x1, y1, x1+r, y1, r)
		cx.closePath()
	}
}

function border_path(cx, x1, y1, x2, y2, sides, radius) {
	cx.beginPath()
	if (sides == BORDER_SIDE_ALL)
		if (!radius)
			cx.rect(x1, y1, x2-x1, y2-y1)
		else
			cx.roundRect(x1, y1, x2-x1, y2-y1, radius)
	else
		border_paths[sides](cx, x1, y1, x2, y2, radius)
}

let shadow_set
draw[CMD_SHADOW] = function(a, i) {
	cx.shadowColor   = a[i+0]
	cx.shadowBlur    = a[i+1]
	cx.shadowOffsetX = a[i+2]
	cx.shadowOffsetY = a[i+3]
	shadow_set = true
}

draw[CMD_BB] = function(a, i) {
	let ct_i = a[i+1]
	let px1 = a[ct_i+PX1+0]
	let py1 = a[ct_i+PX1+1]
	let px2 = a[ct_i+PX2+0]
	let py2 = a[ct_i+PX2+1]
	let x   = a[ct_i+0] - px1
	let y   = a[ct_i+1] - py1
	let w   = a[ct_i+2] + px1 + px2
	let h   = a[ct_i+3] + py1 + py2
	let bg_color      = a[i+2]
	let border_sides  = a[i+3]
	let border_color  = a[i+4]
	let border_radius = a[i+5]
	if (bg_color != null) {
		cx.fillStyle = bg_color
		border_path(cx, x, y, x + w, y + h, BORDER_SIDE_ALL, border_radius)
		cx.fill()
	}
	if (shadow_set) {
		cx.shadowBlur    = 0
		cx.shadowOffsetX = 0
		cx.shadowOffsetY = 0
		shadow_set = false
	}
	if (border_sides) {
		cx.strokeStyle = border_color
		cx.lineWidth = 1
		cx.lineCap = 'square'
		border_path(cx, x + .5, y + .5, x + w - .5, y + h - .5, border_sides, border_radius)
		cx.stroke()
	}
}

draw[CMD_COLOR] = function(a, i) {
	color = a[i]
}

draw[CMD_FONT] = set_font
draw[CMD_FONT_SIZE] = set_font_size

function draw_all() {
	for (layer of a.layers) {
		for (let i of layer) {
			let next_ext_i = get_next_ext_i(a, i)
			check_stacks()
			reset_all()
			while (i < next_ext_i) {
				let draw_f = draw[a[i-1]]
				if (draw_f && draw_f(a, i))
					i = get_next_ext_i(a, i)
				else
					i = a[i-2] // next_i
			}
			check_stacks()
		}
	}
}

// hit-testing phase ---------------------------------------------------------

let hit_set = set() // {id}

let hit_state_map_freelist = map_freelist()
let hit_state_maps = map() // {id->map}

function set_hit_id(id) {
	if (id)
		hit_set.add(id)
}

function hovers(id) {
	if (!id)
		return
	if (!hit_set.has(id))
		return
	let m = hit_state_maps.get(id)
	if (!m) {
		m = hit_state_map_freelist()
		hit_state_maps.set(id, m)
	}
	return m
}

function hit_rect(x, y, w, h) {
	return (
		(mx >= x && mx < x + w) &&
		(my >= y && my < y + h)
	)
}

function hit_box(a, i) {
	let x = a[i+0]
	let y = a[i+1]
	let w = a[i+2]
	let h = a[i+3]
	return hit_rect(x, y, w, h)
}

hit[CMD_TEXT] = function(a, i) {
	let x = a[i+0]
	let y = a[i+1]
	let w = a[i+2]
	let h = a[i+3]
	if (hit_rect(x, y, w, h)) {
		set_hit_id(a[i+TEXT_ID])
		hit_template(a, i, x, y, w, h)
		return true
	}
}

function hit_children(a, i) {

	// hit direct children in reverse paint order.
	let ct_i = i
	let next_ext_i = get_next_ext_i(a, i)
	let end_i = a[next_ext_i-3] // prev_i
	i = a[end_i-3] // prev_i
	let found
	while (i > ct_i) {
		if (a[i-1] == CMD_END)
			i = a[i] // start_i
		let hit_f = hit[a[i-1]]
		if (hit_f && hit_f(a, i)) {
			found = true
			break
		}
		i = a[i-3] // prev_i
	}

	return found
}

hit[CMD_SCROLLBOX] = function(a, i) {
	let id = a[i+SB_ID]
	if (!id)
		return

	let x = a[i+0]
	let y = a[i+1]
	let w = a[i+2]
	let h = a[i+3]

	// fast-test the outer box since we're clipping the contents.
	if (!hit_rect(x, y, w, h))
		return

	set_hit_id(id)

	hit_template(a, i, x, y, w, h)

	// test the scrollbars
	for (let axis = 0; axis < 2; axis++) {
		let [visible, tx, ty, tw, th] = scrollbar_rect(a, i, axis)
		if (!visible)
			continue
		if (!hit_rect(tx, ty, tw, th))
			continue
		set_hit_id(id+'.scrollbar'+axis)
		return true
	}

	// test the children
	hit_children(a, i)

	return true
}

hit[CMD_POPUP] = function(a, i) {

	let popup_layer = a[i+POPUP_LAYER]
	if (popup_layer != layer)
		return

	return hit_children(a, i)
}

function hit_flex(a, i) {
	if (hit_children(a, i))
		return true
	let x = a[i+0]
	let y = a[i+1]
	let w = a[i+2]
	let h = a[i+3]
	if (hit_rect(x, y, w, h))
		hit_template(a, i, x, y, w, h)
}

hit[CMD_H] = hit_flex
hit[CMD_V] = hit_flex

hit[CMD_STACK] = function(a, i) {
	if (hit_children(a, i)) {
		set_hit_id(a[i+STACK_ID])
		return true
	}
	if (hit_box(a, i)) {
		set_hit_id(a[i+STACK_ID])
		let x = a[i+0]
		let y = a[i+1]
		let w = a[i+2]
		let h = a[i+3]
		hit_template(a, i, x, y, w, h)
		return true
	}
}

hit[CMD_BB] = function(a, i) {
	let ct_i = a[i+1]
	let px1 = a[ct_i+PX1+0]
	let py1 = a[ct_i+PX1+1]
	let x = a[ct_i+0] - px1
	let y = a[ct_i+1] - py1
	let w = a[ct_i+2] + px1 + px2
	let h = a[ct_i+3] + py1 + py2
	if (hit_rect(x, y, w, h)) {
		set_hit_id(a[i+BB_ID])
		hit_template(a, i, x, y, w, h)
		return true
	}
}

function hit_all() {

	template_hit = null
	for (let m of hit_state_maps.values())
		hit_state_map_freelist(m)
	hit_state_maps.clear()
	hit_set.clear()

	if (mx == null)
		return

	// iterate layers in reverse order.
	for (let j = a.layers.length-1; j >= 0; j--) {
		layer = a.layers[j]
		// iterate layer's cointainers in reverse order.
		for (let k = layer.length-1; k >= 0; k--) {
			reset_all()
			let i = layer[k]
			let hit_f = hit[a[i-1]]
			if (hit_f(a, i)) {
				j = -1
				break
			}
		}
	}
	layer = null

}

// animation frame -----------------------------------------------------------

function redraw_all() {
	a.length = 0
	for (let layer of a.layers)
		layer_clear(layer)
	check_stacks()

	let i = ui.stack()
	push_layer(layer_base, i)
	make_frame()
	ui.end()
	pop_layer()
	id_state_gc()

	measure_all(0); position_all(0) // x-axis
	measure_all(1); position_all(1) // y-axis
	translate_all()
	draw_all()
	reset_all()
}

reset_all()

// template widget -----------------------------------------------------------

let targs = {}

targs.text  = function(t) { return [t.id, t.s, t.align, t.valign, t.fr] }
targs.h     = function(t) { return [t.fr, t.gap, t.align, t.valign, t.min_w, t.min_h] }
targs.v     = targs.h
targs.stack = function(t) { return [t.id, t.fr, t.align, t.valign, t.min_w, t.min_h] }
targs.bb    = function(t) { return [t.id, t.bg_color, t.sides, t.border_color, t.border_radius] }

let template_hit
let template_hit_i0
let template_hit_i1
let template_hit_t
let template_hit_ch_t
let template_hit_i
let template_hit_x
let template_hit_y
let template_selected_t
let template_selected_ch_t
let template_selected_i
let template_selected_x
let template_selected_y
let template_selected_w
let template_selected_h

function hit_template(a, i, x, y, w, h) {
	if (template_hit && i >= template_hit_i0 && i < template_hit_i1) {
		template_hit_ch_t = template_find_node(a, i, template_hit_t, template_hit_i0)
		template_hit_i = i
		if (clicked || template_selected_ch_t == template_hit_ch_t) {
			template_selected_t    = template_hit_t
			template_selected_i    = template_hit_i
			template_selected_ch_t = template_hit_ch_t
			template_selected_x = x
			template_selected_y = y
			template_selected_w = w
			template_selected_h = h
		}
		return true
	}
}

function template_find_node(a, i, t, t_i) {
	if (i == t_i)
		return t
	if (t.e) {
		let ch_t_i = a[t_i-2] // next_i
		for (let ch_t of t.e) {
			let found_t = template_find_node(a, i, ch_t, ch_t_i)
			if (found_t)
				return found_t
			ch_t_i = get_next_ext_i(a, ch_t_i)
		}
	}
}

function template_add(t) {
	let cmd = cmd_name_map.get(t.t)
	let targs_f = assert(targs[t.t], 'unknown type {0}', t.t)
	let args = targs_f(t)
	ui[t.t](...args)
	if (t.e)
		for (let ch_t of t.e)
			template_add(ch_t, 0)
	if (cmd < 0)
		ui.end(t.t)
}

const CMD_TEMPLATE_OVERLAY = cmd('template_overlay')

function template_drag_point(id, ha, va) {
	let x = template_selected_x
	let y = template_selected_y
	let w = template_selected_w
	let h = template_selected_h
	ui.drag_point(id+'.'+ha+va,
		x + (ha == 'r' ? w : ha == 'c' ? round(w / 2) : 0),
		y + (va == 'b' ? h : va == 'c' ? round(h / 2) : 0),
		'red',
	)
}
ui.template = function(id, t, ...stack_args) {
	ui.stack(id, ...stack_args)
	let i0 = a.length+2 // index of first cmd's arg#1
	template_add(t)
	let i1 = a.length+2 // index of next cmd's arg#1
	ui_cmd_box(CMD_TEMPLATE_OVERLAY, 1, 's', 's', 0, 0, id+'.overlay', t, i0, i1)
	if (template_selected_ch_t) {
		template_editor(id, template_selected_t)
		template_drag_point(id, 'l', 't')
		template_drag_point(id, 'l', 'c')
		template_drag_point(id, 'l', 'b')
		template_drag_point(id, 'r', 't')
		template_drag_point(id, 'r', 'c')
		template_drag_point(id, 'r', 'b')
	}
	ui.end('stack')
}

position[CMD_TEMPLATE_OVERLAY] = function(a, i, axis, ct_x, ct_w) {
	a[i+0+axis] = ct_x
	a[i+2+axis] = ct_w
}

hit[CMD_TEMPLATE_OVERLAY] = function(a, i) {
	let id = a[i+S-1]
	let t  = a[i+S+0]
	let i0 = a[i+S+1]
	let i1 = a[i+S+2]
	template_hit = hit_box(a, i)
	if (template_hit) {
		template_hit_i0 = i0
		template_hit_i1 = i1
		template_hit_t = t
		template_hit_x = a[template_hit_i+0]
		template_hit_y = a[template_hit_i+1]
	}
	template_hit_ch_t = null
	template_hit_i = null
}

draw[CMD_TEMPLATE_OVERLAY] = function(a, i) {
	if (template_selected_t) {
		cx.strokeStyle = 'magenta'
		cx.lineWidth = 1
		cx.beginPath()
		cx.rect(
			template_selected_x + .5,
			template_selected_y + .5,
			template_selected_w - .5,
			template_selected_h - .5,
		)
		cx.stroke()
	}
}

function draw_node(t, depth) {
	ui.font_size(15)
	ui.m(depth * 20, 0, 0, 0)
	//ui.stack('', 1)
		//ui.bb('', 'blue')
		ui.text('', t.t, 'l', 'c', 1)
	//ui.end()
	if (t.e)
		for (let ct of t.e)
			draw_node(ct, depth+1)
}
function template_editor(id, t) {
	ui.popup(id+'.tree_popup', layer_popup, 'it', 'c')
		ui.scrollbox(id+'.sb', 0, null, null, null, null, 200, 100)
			ui.bb('', '#ccc')
			ui.p(10)
			ui.v(1, 10, 's', 't')
				ui.bb('', '#333')
				draw_node(t, 0)
				//ui.template_tree(id, t)
			ui.end()
		ui.end('scrollbox')
	ui.end('popup')
}

ui.widget('template_tree', {
	create: function(cmd, id, t) {
		return ui_cmd_box(cmd, 1, 's', 's', 500, 500, id, t)
	},
	measure: function(a, i, axis) {
		add_ct_min_wh(a, axis, 1000, 1)
	},
	draw: function(a, i) {
		//
	},
})

// drag point widget ---------------------------------------------------------

ui.widget('drag_point', {
	create: function(cmd, id, cx, cy, color, on_drag) {
		let hit = hit_set.has(id)
		if (hit)
			pr('hit', id)
		ui_cmd(cmd, cx, cy, color, id, on_drag)
	},
	draw: function(a, i) {
		let r = 5
		let x     = a[i+0]
		let y     = a[i+1]
		let color = a[i+2]
		cx.fillStyle = color
		cx.beginPath()
		cx.rect(x-r, y-r, 2*r, 2*r)
		cx.fill()
	},
	hit: function(a, i) {
		let r = 5
		let x  = a[i+0]
		let y  = a[i+1]
		let id = a[i+3]
		if (hit_rect(x-r, y-r, 2*r, 2*r)) {
			hit_set.add(id)
			return true
		}
	},
})

// testbed -------------------------------------------------------------------

let test_template = {
	t: 'v', fr: 2, gap: 20, e: [
		{t: 'text', id: 't1', s: 'TP Hello!'},
		{t: 'stack', id: 'st1', fr: 1, e: [
			{t: 'bb', id: 'r1', bg_color: 'hsl(120deg 50% 16%)'},
		]},
	]}

function make_frame() {

	ui.color('white')
	ui.font('Arial')
	ui.font_size(30)

	ui.m(50, null, 50)
	ui.h(1, 20)
		ui.text('t1', 'Hello1!')
		ui.stack('', 1)
			ui.bb('', 'hsl(0deg 0% 16%)')
			if (1) {
			ui.scrollbox('sb1', 1)
				ui.m(50, 50, 0, 0)
				ui.p(20)
				ui.v(1, 20, 'c', 'c')
					// ui.bg('hsl(0deg 0% 16%)')
					ui.shadow('black', 5, 2, 2)
					ui.bb('', 'blue', 1, 'hsl(0 0% 100%)', 20)
					// ui.padding(10, 10, 10, 10)
					ui.text('t2', '[Hello Hello Hello Hello Hello]', '[', 'c', 1)
					// ui.padding(10, 10, 10, 10)
					ui.text('t3', ( max_frame_duration * 1000).dec(1)+' ms', '[', 'c', 1)
					ui.text('t4', (last_frame_duration * 1000).dec(1)+' ms', '[', 'c', 1)
					if (1) {
						ui.m(0, 0, -20, 0)
						ui.popup('p1', layer_popup, 'b')
							ui.bb('', 'hsl(0 100% 50% / .5)', 1, 'hsl(0 0% 100%)', 5)
							ui.p(20)
							ui.text('tp1', 'Wasup?')
						ui.end('popup')
					}
				ui.end('v')
			ui.end('scrollbox')
			}
		ui.end('stack')
		ui.m(10)
		ui.p(10)
		ui.stack('', 1, 'c', 'c')
			ui.bb('', null, 'blt', 'red', 10)
			ui.text('t4', 'Hello Again!', 'c', 'c', 1)
		ui.end('stack')
		ui.template('tpl1', test_template)
		// ui.text('t3', '...and again.', 'c', 'c', 1)
	ui.end('h')

	// redraw()

}

// debugging -----------------------------------------------------------------

function draw_debug_box(a, i) {
	if (!DEBUG) return
	// if (a[i-1] != CMD_POPUP) return
	let x = a[i+0]
	let y = a[i+1]
	let w = a[i+2]
	let h = a[i+3]
	let mx1 = a[i+MX1+0]
	let my1 = a[i+MX1+1]
	let mx2 = a[i+MX2+0]
	let my2 = a[i+MX2+1]
	let px1 = a[i+PX1+0]
	let py1 = a[i+PX1+1]
	let px2 = a[i+PX2+0]
	let py2 = a[i+PX2+1]
	cx.beginPath()
	cx.fillStyle = 'hsl(240deg 100% 50% / .4)'
	cx.rect(x, y, w, h)
	cx.fill()
	cx.beginPath()
	cx.fillStyle = 'hsl(120deg 100% 50% / .4)'
	cx.rect(x+mx1, y+my1, w-mx1-mx2, h-my1-my2)
	cx.fill()
	cx.beginPath()
	cx.fillStyle = 'hsl(0deg 100% 50% / .4)'
	cx.rect(x+mx1+px1, y+my1+py1, w-mx1-mx2-px1-px2, h-my1-my2-py1-py2)
	cx.fill()
}

function pr_layer(a) {
	let i = 2
	let depth = 0
	let n = a.length
	let pr1 = pr
	while (i < n) {
		let cmd = a[i-1]
		if (cmd == CMD_END)
			depth--
		let indent = (' ').repeat(depth)
		let cmd_s = cmd_names[cmd]
		if (cmd < 0) {
			let next_ext_i = a[i+NEXT_EXT_I]
			let next_ext_cmd_s = cmd_names[a[next_ext_i-1]]
			pr1(indent + '(' + cmd_s, i)
			depth++
		} else if (cmd == CMD_END) {
			pr1(indent + ')', i)
		} else {
			pr1(indent + cmd_s, i)
		}
		let next_i = a[i-2]
		i = next_i
	}
	assert(depth == 0)
}

}()) // module function
</script>
</body>
</html>
